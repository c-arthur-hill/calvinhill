import {
  isRef,
  onBeforeUnmount,
  onMounted,
  shallowRef,
  watch
} from "./chunk-UFEOIX5A.js";
import {
  State,
  interpret,
  spawnBehavior,
  toObserver
} from "./chunk-KVUFFGUF.js";
import "./chunk-OZI5HTJH.js";

// node_modules/@xstate/vue/es/useInterpret.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function useInterpret(getMachine) {
  var _a = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    _a[_i - 1] = arguments[_i];
  }
  var _b = __read(_a, 2), _c = _b[0], options = _c === void 0 ? {} : _c, observerOrListener = _b[1];
  var machine = typeof getMachine === "function" ? getMachine() : getMachine;
  var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, ["context", "guards", "actions", "activities", "services", "delays", "state"]);
  var machineConfig = {
    context,
    guards,
    actions,
    activities,
    services,
    delays
  };
  var machineWithConfig = machine.withConfig(machineConfig, function() {
    return __assign(__assign({}, machine.context), context);
  });
  var service = interpret(machineWithConfig, interpreterOptions).start(rehydratedState ? State.create(rehydratedState) : void 0);
  var sub;
  onMounted(function() {
    if (observerOrListener) {
      sub = service.subscribe(toObserver(observerOrListener));
    }
  });
  onBeforeUnmount(function() {
    service.stop();
    sub === null || sub === void 0 ? void 0 : sub.unsubscribe();
  });
  return service;
}

// node_modules/@xstate/vue/es/useMachine.js
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function useMachine(getMachine) {
  var _a = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    _a[_i - 1] = arguments[_i];
  }
  var _b = __read2(_a, 1), _c = _b[0], options = _c === void 0 ? {} : _c;
  function listener(nextState) {
    var initialStateChanged = nextState.changed === void 0 && Object.keys(nextState.children).length;
    if (nextState.changed || initialStateChanged) {
      state.value = nextState;
    }
  }
  var service = useInterpret(getMachine, options, listener);
  var initialState = service.machine.initialState;
  var state = shallowRef(options.state ? State.create(options.state) : initialState);
  return { state, send: service.send, service };
}

// node_modules/@xstate/vue/es/useActor.js
function isActorWithState(actorRef) {
  return "state" in actorRef;
}
var noop = function() {
};
function defaultGetSnapshot(actorRef) {
  return "getSnapshot" in actorRef ? actorRef.getSnapshot() : isActorWithState(actorRef) ? actorRef.state : void 0;
}
function useActor(actorRef, getSnapshot) {
  if (getSnapshot === void 0) {
    getSnapshot = defaultGetSnapshot;
  }
  var actorRefRef = isRef(actorRef) ? actorRef : shallowRef(actorRef);
  var state = shallowRef(getSnapshot(actorRefRef.value));
  var send = function(event) {
    actorRefRef.value.send(event);
  };
  watch(actorRefRef, function(newActor, _, onCleanup) {
    state.value = getSnapshot(newActor);
    var unsubscribe = newActor.subscribe({
      next: function(emitted) {
        return state.value = emitted;
      },
      error: noop,
      complete: noop
    }).unsubscribe;
    onCleanup(function() {
      return unsubscribe();
    });
  }, {
    immediate: true
  });
  return { state, send };
}

// node_modules/@xstate/vue/es/useSelector.js
var defaultCompare = function(a, b) {
  return a === b;
};
function useSelector(actor, selector, compare, getSnapshot) {
  if (compare === void 0) {
    compare = defaultCompare;
  }
  if (getSnapshot === void 0) {
    getSnapshot = defaultGetSnapshot;
  }
  var selected = shallowRef(selector(getSnapshot(actor)));
  var updateSelectedIfChanged = function(nextSelected) {
    if (!compare(selected.value, nextSelected)) {
      selected.value = nextSelected;
    }
  };
  var sub;
  onMounted(function() {
    var initialSelected = selector(getSnapshot(actor));
    updateSelectedIfChanged(initialSelected);
    sub = actor.subscribe(function(emitted) {
      var nextSelected = selector(emitted);
      updateSelectedIfChanged(nextSelected);
    });
  });
  onBeforeUnmount(function() {
    sub === null || sub === void 0 ? void 0 : sub.unsubscribe();
  });
  return selected;
}

// node_modules/@xstate/vue/es/useSpawn.js
function useSpawn(behavior) {
  var actorRef = spawnBehavior(behavior);
  return actorRef;
}
export {
  useActor,
  useInterpret,
  useMachine,
  useSelector,
  useSpawn
};
//# sourceMappingURL=@xstate_vue.js.map
