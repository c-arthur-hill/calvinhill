Might want to do database + Eloquent after basics
Then Digging Deeper
Then Security

nova

Routing
-------
Required parameters {} can be type hinted to closure / controller
Parameters go  afte dependencies
Placing ? mark after parameter makes it optional. Need to define a default value then.
Can place validation constraints on parameters with ->WhereIn, WhereAlpha, where, etc.


Middleware, controllers, subdomains, route name prefix may all be grouped

Can inject a model like /{user), then function(User $user)
{post:slug} will use slug property
Laravel automatically uses implicite relation in /{user}/{post:slug} bc :slug part. can turn this on / off

Can globally define custom model binding resolution logic, bind at the top of the routeserviceprovider bind
or resolveRouteBinding method inthe model.

ratelimiters exist.

forms are always POST
but then @method('PUT')
Route::current()

Middleware
----------
Putting code after $next($request) performs the middleware after the request has been handled
Add middleware in Kernel property or on routes
Middleware can be added to groups, with exceptions
Middleware can be aliased
May need to sort middleware priority by adding property in Kernel.
Can pass parameters to middleware like Route::get(...)->middleware('some-middleware-alias:parameter1,parameter2,parameter3')
Using FastCGI, a middleware can add a 'terminate' method called after the server sends the response. Useful for things like queueing jobs
If a middleware is not registered as a singleton, the terminate and handle methods will receive different instances of the middleware

CSRF
----
CSRF ex. is when user is logged into your site, visits another, then a form submits to e.g. change the user's passwords to the hackers
CSRF token makes sure the request comes from your site.

Controllers
-----------
Can create a single action controller using __invoke magic method
Can also specify middleware for a controller in the constructor like $this->middleware('example-middleware');
Can also define that middleware directly by using a closure
php artisan make:controller ExampleController --resource --model=Example
API resource controllers exclude the html form routes
Can create "nested" resource routes with dot notation 'User.comments', which generate urls like /user/{user)/comments/{comment}
Can change parameter labels in rouce routes with ->parameters(['example' => 'new-example']);
To override or create additional routes on resources, place them before the resource controller
A singleton resource controller is for something like a profile that only has one thing.
Can also build singleton like Route::singleton('photos.thumbnail', ThumbnailController::class);
Can make singleton ->creatable();

Requests
--------
$request->routeIs([name or wildcard matching route path])
$request->url() or $request->fullUrl(); depending on query string or not
can also retreive headers, scheme, host, ip, etc.
$request->input('name', 'Calvin') gets user-input value for name regardless of http verb
Can use dot notation for nested forms
$request->query does same for querystring
$request->boolean is useful for turning "true" or "on" from a checkbox into a true or false
$request->date()
$request->has() can be used to check if the user input is present in the request
-$request->flash() will flash the user input to the session, also redirect()->route('route-name')->withInput()
-$request->old('some-value') will then get the previously flashed data from the session
$request->cookie('some-cookie') does the obvious
$request->file('example')
->isValid()
->path()
->extension()
->store('s3' or 'images') etc.

Responses
---------
Can return string, array or Eloquent Collection and laravel will convert to html, json or json response, respectively
$response->cookie() sets cookie
all cookies ar eencrypted by middleware by default
back() will redirect back to last route
redirect()->route('this.is.for.a.named.route')
Can pass a eloquent model to a parameter e.g. route('picture', Picture)
redirect()->away('google.com') will redirect to external site
Can use with and withinput to flash session data to redirect response
can use view with response()->view('index', $data, 200)->header(...) to specify a view response but also set headers
response()->json([...])
response()->download($pathToFile)
response()->streamDownload(...) takes a string response and returns a download response. So, e.g. return a file from another website to the user without evber saving it to server disk
response()->file($pathtoFile) is like download but instead of downloading, it will just display in the browser (think pdf labels)

View
----
If in normal directory location, can alias view in response with like 'example.blade.php' => 'example'
Can share context across all views with the View::share('key', 'value') from within service provider
Can share context across specific views with a view composer
Facades\View::composer('example-blade-view', ExampleCreatedComposerClass::class)

Blade
-----
Can put any php inside curly braces {{ phpinfo() }}

un-escape html by {!! $htmlString !!} - for. ex. if storing html in database
@{{ $withAtSign }} will be ignored by blade. Useful for writing vue/react
@@if() will also be rendered directly as @if
@verbatim will escape large blocks of js
{!! json_encode($array) !!} is like {{ Js::from($array) }} (!! means don't want {'example': '<something>'} to be converted to {'esxmple': '%27something%28'}

@if (count($record) === 1) example @elseif (count($record) > 1) example2 @else example-1 @endif
@isset($variable) something @endisset
@empty($records) something not @endempty
@auth @endauth checks if user is authenticated
@guest @endguest checks if not authenticated
@auth('admin')@endauth checks specific uathentication guards
@env(['prod', 'test']) checks environemtn
@hasSection('nav')<h1>hello</h1>@endif only inserts if the template inheritance 'nav' has content
@sectionMissing does opposite
@switch($i) case(1)asdff @break case(2)asd@break @default asss @endswitch
@for($i = 1; $i < 10; ++i) soemthing @endfor
@foreach($users as $user) {{ $user->id }) @break($user->id == 27) {{ $loop->index }} @continue @endforeach
@while ($i) {{ --$i; }} @endwhile

<span @class([
    'red' => $isRed,
    'blue' => $isBlue,
    ])

    @style([
    'background-color: green' => $isGreen
    ])
    >some text</span>
@checked($isChecked)
@selection($isSelected)
@disabled($isDisabled)
@readonly($isReadOnly)
@required($isRequired)

<div> @include('some.child', ['additional-context' => 4]) </div> some.child will inherent all parent data
@includeWhen($ifTrue, 'some.child' , ['addtl' => 3])
@each('view.name', $someArray, 'iteratorVariableName') will render view.name for each entry in $someArray

@php $i = 1; @endphp
{{-- comment --}}

Class based components and anonymous components
php artisan make:component Alert
app/view/Component/Alert.php + resources/views/components/alert.blade.php
php artisan make:component Alert --view creates an anonymous component, that means it has no class jsut a blade resource
<x-alert>
<x-alert type="error" :message="$message"> will pass $type = 'error'; $message = $message; to the
__construct(public string $type, public string $message) constructor
{{ $message }} can render variable inside componeent
can also write <x-alert :message>
<x-button ::class="something"> -> <x-button :class="something"> Can use :: to escape things that shouldn't be passed (like vue attributes)
can call public class methods (.e.g public function isSelected() ...) like <option {{ $isSelected($value) ? 'selected' : ''}}></option>
Component class render method can return a closure that will receive the component name, attributes and slot as an array : return function (array $data) {// $data['componentName']; $data ['attributes']; $data['slot']; return '<div>something</div>'; };
The compnent render method should either return the string name of a blade view or the inline contents to be evaluated as a blade view
any html attributes specified in the component tag are passed through the component class to the rendered blade via a "attributes" variable
<x-alert class="mt-4"> --> <div {{ $attributes }}>Rendered component</div> would have a class="mt-4"
Can merge and conditionally merge attributes using methods on the attributes variable
{{ $slot }} in the implementation will render whatever is placed inside the component tag. Can define-multiple by <x-slot:some-name>
<x-alert>
<div class="alert">
<h1 {{ $title->attributes }}>{{ $title }}</h1>
<div>{{ $slot }} </div>
</div>
</x-alert>
called with <x-alert ><x-slot:title class="h1">Warning</x-slot> This is then the slot</x-alert>
Can use {{ $component->someComponentClassMethod('asdf') }} inside a scoped slot
Notice $title->attributes above for passing in attributes to a scoped slot
Can directly return the component markup from the render method on component class to avoid creating separate blade view
An anonymous component has no class. Useful if I want to be able to just include a subview in blade without an include
Can use an index.blade.php vile inside a subdirectory to be able to use something like
<x-accordian> // index
<x-accordian.item>slotted info</x-accordian.item>
</x-accordian>
In an anonymous component, can specify @props['propName1', 'propName2']) to specify which should be treated as props (vs. attributes)
Can pass child components parent props with @aware(['propName1'])
Generally define one parent layout <x-layout>, then use that as "body" in most components

@csrf
@method
@error('validationBagName') acts as a conditional if
@push('scripts')<script src="/example.js"></script>@endpush -> $stack('scripts')
@prepend is like push, but at beginning
@inject('alias', 'App\Services\SomeService') --> {{ $alias->getMethod() }}

Fragments can be used to only render part of a view
@fragment('top-of-packing-slip')<img>@endfragment
return view('some-view-that-has-multiple-fragments')->fragment('top-of-packing-slip');

Can register custom blade directives using Blade::directive('alias', closure) inside boot method of app service providers
Blade::stringable allows overriting representation of {{ $object }} from __toString() to something custom

Asset Bundling
--------------
Vite rewrites relative urls to a bundled asset
Vite leaves absolute paths untouched. These should reference assets already in the public folder
Can automatically import resources in resources/images and resources/fonts by addin tto resources/js/app.js:
import.meta.glob(['../images/**', '../fonts/**'])
<img src="{{ Vite::asset('resources/images/logo.png') }}">
Vite dev server can automatically refresh browser when certain file paths are changed. Meh.
Vite::macro('image', fn(string $asset) => $this->asset("resources/images/$asset") -> <img src={{ Vite::image('logo.png') }}">
prepending VITE_ to env variable will inject it into js
import.meta.env.VITE_SOME_ENV_VAR to access
can set nonce on csp to prevent running outside scripts

URL Generation
--------------
url("/posts/1"); --> https://www.calvinhill.com/posts/1
url()->current()
->full() // include query string
->previous() // last request
can also use facade URL::full()
route('named.route') is like url for a .. named route // useful if routes change, which they do
route('named.route', ['post' => 1])
route('named.route', ['post' => $post])
URL::signedRoute('unsubscribe', ['user' => 1]) // includes a hash in the querystring. Only user 1 can use this to unsubscribe
URL::temporarySignedRoute(...) // expires after awhile
For a signed route need to use $request->hasValidSignature() in the action
Can also validate signature in middleware
action([SomeController::class, 'actionMethod']) // like url or route, but for Controller action

Session
-------
file session driver is default
Redis is useful when moving past one server
php artisan session:table can create migration to setup db for handling sessions

$val = $request->session()->get('key', 'defualt'); // or $request->session()->all()
$request->session()->put('key', 'value');
$request->session()->push('key', 'value2'); // this would append 'value2' if 'key' pointed to an array value

$val = session('key');
session(['key' => 'value']); // can set a key=>val in global session

$request->session->flash('key', 'value') -> available for next request, things like error messages
$request->old('key') will retrieve flash

can block certain session url endpoints to avoid concurrency bugs

Request validation
------------------
(in controller) $request->validate(['title' => 'required|unique:posts:max:255']); // will automatically redirect to last route if not successful
if the request is xhr, instead of a redirect, it will return a json response with the error
Can also delimit rules as an array: ['required', 'unique:posts', 'max:255']
if using ['bail', 'rule1', 'rule2'] rule2 won't be evaluated if rule 1 fails
can specify a nested form field with 'parent.child'
middleware automatically passes the errors to the view @errors->all()
$request->old('title') will get error from last request aka <input value="{{ old('title') }}>
often need to add nullable to validated optional fields e.g. 'publish_at' => 'nullable|date', because null gets converted to empty string by convertEmptyStringsToNull middleware which is not a valid date

php artisan make:request StorePostRequest // a form request
has two methods: authorize and rules
typehint the request passed to the controller like public function store(StorePostRequest $request) {} // validation is handled automatically
can add an "after" method to the form request to perform further validation after the other validation is complete
the after methods can return an array of classes with the __invoke method defined.
can customize the redirect location
can customize the error messages e.g. 'title.required' => 'The title is required'
can modify data before validation with prepareForValidation() method, e.g. lowercasing, trimming, escaping, etc.
can also normalize data after passing validation before with passedValidation() being sent to the controller
with multiple forms on a page, each form's message bag can be named to put the errors on the right form

Can manually make a validator, but imo, better to either use standard request validator or make a form validator

$validated = $request->validated();
$validated = $request->safe()->all() or $request->safe()->only(['title']) or $request->safe()->except('title')
foreach($request->safe() as $eachSafe) ... // as an array

interesting validation rules:
distinct 'users.*.id' // array of user ids are all unique
starts_with end_with// check the a string start or ends with some other
between:min,max // supports strings, numberics and files
active_url // checks dns records at runtime
alpha_num // several variations
different:field // make sure this is different than another field
exclude // remove this value from validated results (unmapped)
exists:table,column // 'state' => 'exists:states' will check if the input string exists in the 'state' column of the 'states' db table
image // checks file type
regex:pattern
unique:table,column // reverse of exists, can be used with ignore to allow user to change their email but not to another user's email

$validator->sometimes(...) to specify a closure for when to add a field
if validating arrays, always specify which array keys are allowed 'user' => 'array:username, locale'
when validating array, the error message can include the index position with 'Please fix :position'

Laravel has a oop file validator for specifying file validation. Same functionality as above approach
It also has custom password validator that can check length/symbols and whether it's been compromised in a breech

Can create a validation rule and pass it as a class to an array of validation rules

An implicite rule ONLY implies that an attributes is required (the custom validation rule will run). If empty data is not allowed -> the rule should fail

Error handling
--------------
Can add closures to App\Exceptions\Handler->register() $this->reportable method
The type hint to each closure says which type of exceptions the closure should intercept
Can add ->stop to prevent Laravel doing it's normal stuff on customly handled exceptions
Can define custom context to each exception in the context method
Define per exception context on the exception class context method e.g. order Id of invalid order
report($exception) can be used in catch block. It logs the exception but allows the request to continue
the $levels property maps each Exception class to a Psr\Log\LogLevel
By default, Laravel generates an error response for unhandled exceptions. This can be over-written/modified
Defining report and render methods on the custom Exception will cause these to be used
abort(404) (or other code) generates a response corresponding to that http error code
can customize blade views for each error view with resources/views/errors/404.blade.php

Logging
-------
the default logging is "stack", which aggregates all the logging channel into the "single" log
The single log is one file written to disk.
Another common setup is daily, where logs are written to a separate file each day
Can configure logging deprecation warnings
A common approach with "stack" logging is to aggregate multiple log channels in one, then have each channel define which severity level it logs

Log::emergency($message)  // alert - debug - critical - error - warning - notice - info - debug
Log::emergency($message, ['user' => $user->id])
Log::withContext(['request-id' => (string) Str::uuid()]) will force all subsequent log entries in a particular channel to include the request id
To share across all channels use Log::shareContext(['request-id' ...])
Log::channel('non-default-channel')->emergency($message)
Can define runtime on-demand channel using Log::build(['path' => some_custom . $var . '.log'])

Can customize Monolog instance by defining a 'tap' property that defines an invokable class that can modify it

Most monologue formatting is done by specifying a handler e.g. SlackHandler then setting the configurating via logging.php that would be passed to it's constructor
In particular, can pass the formatter and 'formatter_with' to specify how log entries should be written

Commands
--------
php artisan list // shows all commands
php artisan help migrate // shows help for migrate command
php artisan tinker // laravel aware shell
php artisan make:command SomeCommand
inside routes/console.php can use the Artisan::command(...) method to register closure-based commands
a command can implement the Isolatable contract to ensure only one instance runs at a time

An argument is specified without any key.
Can define arguments in the signature: protected $signature = 'mail:send {user}'; // {user?} or {user=foo} like route params

An option is specified with a double hyphen
A signature can define a "switch" option that takes no value like {--send-immiediately} // -- is the syntax
A signature can define an option with a value using {--send-after=} // the syntax is --XXXX=
An option with a value can define a default like {--send-after=300000}
$signature = 'mail:send {user?*}' can accept zero (* means optional) or many space-separated values (*) // both arguments and options
Array inputs should be passed like php artisan mail:send user=1 user=2 user=3 user=4
Can define a description of an input after a spaced colon: {user?* : the id of a user}
Can access arguments and options with $this->arguments() and $this->options()

Can ask user for input using $var = $this->ask or ->secret // Secret will hide their e.g. password response
Can ask for confirmation with $this->confirm(...)
Autocomplete with $this->anticipate('Today is ...', ['Mon', 'Tue', 'Wed']);
$this->choice('question?', [1, 2, 3], $defaultIndex, $maxAttempts, $allowMultipleTries);
Can output variables with $this->line(...) | info | comment | question | warn | error
$this->newLine($x) will output $x newlines
$this->table(['first', 'last'], $arrayOfFirstAndLastNames) outputs a formatted table
$this->withProgressBar($array, closure()); will show what % of $array the closure has been performed on

Artisan::call('some:commad', [...$args]) to call a command outside artisan
can also use Artisan::queue to run it programmatically using the queue
Inside a command, can use $this->call(...) or $this->callSilently(...) // call silently suppresses output

Can use $this->trap(SIGTERM, closure); // where SIGTERM is an OS signal to define how a command should handle signals inside the handle method

Broadcasting
------------
Clients side js connects to named channels and laravel broadcasts events to them
Not going to read this because it's tied to commercial vendors.
There is one open source option

Cache
-----
Cahing is for storing data that will be used again and took awhile to compute
php artisan cache:table generates a migration for using the db as a cache
Usually use memcached or redis
Cache::get('key', 'default') // default value is optional, otherwise null is returned
Cache::store('some-store')->get('key')
$value = Cache::remember('users', $timeValueInSeconds, fn () => {return $val;} // Either gets the value from the cache or runs the closure and sets the cache value to the var
Cache::rememberForever doesn't expire
Cache::put('key', $val, $seconds) // $seconds is optional
Cache::add('key', $val, $seconds) will only put the value if it doesn't exist, but it's atomic
Cache::forget('key')
Cache::flush() // remove all

cache('key') // Cache::get
cache('key', 'val', $seconds) // Cache::put
cache()-> // Same as Cache::

Cache tags allow "grouping" cache keys by assigning them tags
Cache::tags(['people', 'artists'])->put('John', $john, $seconds);
Cache::tags(['people', 'artists'])->get('John'); // cannot retrieve john w/o Tag. almost like 'people.john' key
Cache::tags(['people'])->flush()

Using Redis, php artisan cache:prune-stale-tags should be scheduled on a cron

$lock = Cache::lock('key', 10);
if ($lock->get()) { ; ; ; ; $lock->release();} // attempts to get lock, which is when the timer starts
$lock->get can also take a closure and release the lock after the closure finishes
$lock->block(5) will try to get the lock, if it fails it will keep trying for 5 s before throwing an exception

a $lock has an ->owner() that can be used to restore a lock in another process, then release it
This is useful for e.g. dispatches a queue job in a web request, then releasing lock after queue job

Collections
-----------
An attempt to gloss over php array function confusion
Eloquent queries always return a collection
collect($someArray)
generally, each collection method returns a new collection

Collection::macro('alias', closure) --> collect($someArray)->alias() // should be declared in boot method of a service provider
Additional arguments to the macro like fn($something) can be passed collect($someArray)->alias('something')

all() / returns array from collection
avg('some-key') / returns average value of 'some-key' in each sub-array. On a flat array, returns average
chunk(2) / [1, 2, 3, 4] -> [[1, 2], [3, 4]]
chunkWhile(fn (string $value, int $key, Collection $chunk) {// when to chunk})
collapse / flatten nested
collect($collection) / convert lazy collection into normal collection
(collection(['first', 'second']))->combine([1, 2]) / ['first' => 1, 'sedcond' => 2]
concat / starts with a collection, takes another array or collection, reindexes the keys in both in order, then concats second to first
contains / check if string/('key', 'value')/ closure evaluating to true exists
containsOneItem / count() ==  1
containsStrict / like contains but uses strict comparison
count / count
countBy() / either a function or like [1, 1, 1, 2, 2] => [1 => 3, 2 => 2]
crossJoin / ['a', 'b'] => [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
dd / debugging. Prints items and stops script
collection([1,2,3,4]->diff([1,2]) / values in original collection not in passed [3,4]
diffAssoc / like diff, but for (key,value) pairs in associative array
diffKeys / like diff associ but will remove original keys even if the value is different
doesntContain / opposite of contains
dot / ['top' => ['nestted' => ['key' => 'value']]] => ['top.nested.key' => 'value']
dump / output key / values in collection
duplicates() / returns duplicated values from an array [1, 2, 2, 3] => [2]
duplicates('some-key') / returns duplicate values for key [['test' => 1], ['test' => 1], ['prod' => 2]] => ['test' => 1]
duplicatesStrict / like duplicates but uses strict comparison
each() / like map, passes each collectio item into aclosure. Map collects the return responses through
eachSpread / expands each nested item in a collection and passes it as parameters to a closure e.g. ['Calvin', 'Arthur', 'Hill'] -> fn ($firstName, $middleName, $latName) {}
every() / does every value in a collection pass a truth test [2,4,6] => fn($val, $key) {return $val %2 == 0} -> true
except / filter specified keys out of a collection
filter() / keep only items that pass a truth test
first() / first item in collection that passes a truth test
firstOrFail / like first, but if none are found, throw an exception
firstWhere / in a nested array, find the first item containing a key/val pair. In a flat, can pass in a comparison opeerator (> 18)
flatMap / runs a closure on each item in array then flattens the result one level. Useful if the map returns a string explosion
flatten / flattens to a single dimension, or if an arg is passed, flatten that number of "depths". [[[1,2,3]], [4,5,6]] => [1,2,3,4,5,6]
flip / switch keys and values
forget('key') / remove key/value pair with given key. Operates in place (not immutable)
forpage($pageNumber, $itemsPerPage) / returns a collection showing items projected to be on page e.g. collection([1,2,3,4,5,6,7,8])->forPage(2,3) -> [4,5,6]
get('key') / return value of given key or null or default
groupBy / [['first' => 'Calvin', 'last' => 'Hill'], ['first' => 'Calvin', 'last' => 'Coolidge'], ['first' => 'George', 'last' => 'Washington']] ->groupBy('first') =>  ['calvin' =>  [['first' => 'Calvin', 'last' => 'Hill'], ['first' => 'Calvin', 'last' => 'Coolidge']], ['George' => ['first' => 'George', 'last' => 'Washington']]]  Can also group by multiples
has('key') / does key exist in collection
hasAny(['key1', 'key2', 'key3']) / has but for array of keys
implode('key', ',') or implode(',') or implode(transorm-closure(), ',') / join items in collection into string
intersect() / filter any items in first collection not present in second. Maintains key position
intersectAssoc() / return key value pairs present in all collections
intersectByKeys() / return collection of key value pairs from the original collection that have matching keys in the passed collection
isEmpty() / count(0)
isNotEmpty
join(',') / joins values into string. Can pass a second parameter for last delimeter
keyBy() / [['first' => 'Calvin', 'last' => 'Hill'], ['first' => 'Calvin', 'last' => 'Coolidge'], ['first' => 'George', 'last' => 'Washington']] -> keyBy('first') -> [['first' => 'Calvin', 'last' => 'Coolidge'], ['first' => 'George', 'last' => 'Washington']]
keys() / return all keys in collection
last() / last element that passes a truth test or w/o a closure, that last overall
lazy() / return lazy collection from collection. $bigCollection->lazy()->where()->where()->count() // only original collection in memory. The generated ones basically "flip" in place
macro() / add methods to collection class at runtime
make() / create a collection from an array Collection::make($someArray)
map() / run closure on each item then takes the return values into a new collection
mapInto() / use passed class constructor as map function
mapSpread() / pass nested collection into callback as expanded e.g. [[1,2,], [3,4]] -> fn($odd, $even)
mapToGroups / callback function should return array. The final collection will group by the keys in the callback-returned array
mapWithKeys / like mapToGroups but the result won't be 'key' => [$val1, $val2, $val3...], but 'key' => 'val'
max('key') / max val for key in nested collection. Without a key, it will just give highest value
median / median value for key, or without a key, median of all values
merge / merge given collection with original. The passed collection keys will over-write existing original. Numeric keyed collections will  be appended.
mergeRecursive / like merge, but instead of over-writing the multiple values are put in to a sub array. e.g. collection(['key' => 1])->mergeRecursive(['key' => 2])  -> ['key' => [1,2]]
min / like median or max
mode / like min
nth(4) / like if index % 4. Takes every 4th element. Can pass an optional offset
only / filter any items in collection that don't have the given keys
pad(items, $value) / will fill array with $val until it reaches the desired # of items. If negative it will pad to the left until count() ==  abs($items)
[$passes, $fails] = partition(truthinessClosure) / breaks into those that pass and those that don't
pipe(closure) / passes collection itself to this closure
pipeInto(ClassName::class) / passes collection into constructor of class
pipeThrough / like pipe but passes through multiple closures like ->pipe(fn($collection){})->pipe(fn($results){})...
pluck('key') / return collection containing all values in nested collection for a particular key. Can optionally pass another key, whose value will  be used as the key for each value in the result
pop() / last item from the collection
prepend / add item to start cof collection
pull('key') / remove item from collection with key 'key' and return it: ['key' => $val]
push() / append item to end of collection
put('key', 'value') / sets key-val in collection
random() / random item from collection. Can pass optional number of random items to return
range(2,6) / [2, 3, 4, 5, 6]
reduce(function (?int $carry, $value, $key) {}) /  reduce function
reduceSpread(fn($carry, $arrayCarry, $currentValueFromCollection){ // return [$newCarry, $newArrayCarry];}, $originalCarry, $originalArrayCarry) / Like reduce, but operates on an array carry that is passed through each iteration
reject(function truthCallback($key, $value){}) / if truthCallback returns true the item is filtered from the collection
replace / like merge but over-writes both string and numeric e.g. collect(['first', 'second'])->replace([1 => 'third']) -> ['third', 'second']
replaceRecursive / like replace, but you can pass nested array structure like 2 => [1 => 'King'] and end up with ['asdf', 'asdf2', ['asdf3', 'King']]
reverse / reverse the order of the collection, maintaining keys -> [4 => 'last' ... 1 => 'first']
search(4) / return key of item with given value
shift($n=1) / remove and return first $n collection items
shuffle() / randomly change order of collection
skip($n) / return new collection with first $n items removed
skipUntil(truthClosure) / return all items from front of collection until truthClosure returns true. Can also pass value e.g. skip all values until $value==3
skipWhile / opposite of skipUntil
slice($start, $size) / returns items between indexes $start and $start + $size
sliding($newCollectSize, $stepSize) / take chunks of collection in size $size [1, 2, 3, 4, 5, 6] -> [[1, 2], [2, 3], [3, 4], [4,5], [5,6]]
sole / like first but only returns if the item is the only in the collection that passes the truth test. Without arguments it will return the item only if it is only in the collection
some / alias for contains
sort / maintaining keys, sort the array. So [4,3,2,1] -> [3=>1, 2=>2, 1=>3, 0=>4]. Can use ->values() to re-key. Can take callback
sortBy('key') / sort by given key, callback or array of sort operations [['name', 'asc'], ['age', 'desc']]. can accept sort flags to define numeric, string, etc. comparator
sortByDesc / sortBy in opposite order
sortDesc / sort in opposite order
sortKeys / sort by keys
sortKeysDesc / sort by keys in opposite direction
sortKeysUsing($callBack) / sort by keys using provided comparison  callback returning an integer lt, et, gt zero
splice($startIndex, $numberOfItem, [$replaceWith..]) / remove items from array (and optionally replace with provided) and return the new collection. Mutator
split(3) / split collection into 3 groups
splitIn(3) / split but only the last group can be smaller so [1,2,3,4,5,6,7,8,9,10]->[[1,2,3,4], [5,6,7,8], [9,10]] instead of [1,2,3,4], [5,6,7], [8,9,10]
sum() / sum all items in collection. Or values of passed key argument.
take($n) / if positive, first $n items of collection. If negative, last abs($n) items of collection
takeUntil() / either take until a truth condition passes or if passed a value, until that value is encountered
takeWhile() / reverse of take until
tap / pass collection to closure, but then it returns the original collection. Useful for e.g. chaining log dispatch
Collection::times($n, closure($i) / create new collection by calling closure $n times
toArray / turn collection back into plain array
toJson / turn collection into json serialized string
tranform / call callback on each item in collection and replace the current item with the result. Mutable. Replaces in-place
undot / collect(['dot.foo' => 1, 'dot.bar' => 2, 'dot.baz' => 3])->undot() -> ['dot'  => ['foo' => 1, 'bar' => 2, 'baz' => 3]]
union / combines original collection with a given array. The original items will be preferred
unique / return only unique values. keys are maintained. Can pass a key to determine uniqueness e.g. one person of each age in census data
uniqueStrict / like unique but uses strict comparison. Means it can return like [1, '1']
unless(boolean $true, ifNotTrueCallback, ifTrueCallback) / opposite of when. Calls the first callback on the collection if the first arg is false. If the first arg is true (optioanlly) calls second callback
Collect::unwrap() / given an array or collection, returns an array. Given a primitive, returns a primitive
value / return value of key from first item in collection collection([['first' => 'Calvin'], ['first' => 'Jake']])->value('first') -> 'Calvin'
values() / reset collection keys to consecutive 0-indexed integers
when(bool $truthValue, callback, callback) / when truthValue, pass collection to first callback. Otherwise (optionally) pass it to the second
whenEmpty(callback, optionFallBackCallback) / if the collection is empty, pass it  to the first Callback, otherwise (optionaly)the second
whenNotEmpty / like whenEmpty
where('price', '==', 100) / Second paramter is optional. Defualts to '==', can pass most '<=', '<', etc. operators. [['price' => 100, 'name' => 'Apple'], ['price' => 101, 'name' => 'Samsung']] => [['price' => 100, 'name' => 'Apple']]
whereStrict / can just change operator, which is shorter and more explicite
whereBetween('key', [$start, $end]) / like where but for double comparison
whereIn('key', [$opt1, $opt2, $opt3]) / like where, but the collection value for key has to equals one of the options
whereInStrict( / see whereStrict
whereInstanceOf(ClassName::class) / filter collection items that aren't of type ...
whereNotBetween / like whereBetween
whereNotIn / like whereIn
whereNotInStrict / where items with key 'key' are not strictly equal to one of the values passed
whereNotNull / filters keys with null values
whereNull / only returns keys with null values. Could also use where('key', '===', null)
wrap / creates a collection from primitives, arrays or existing collections
zip / (collect(['first', 'last'])->zip(['Calvin', 'Hill']) -> ['first' => 'Calvin', 'last' => 'Hill']

higher order messages: can use certain common collection methods as properties like collection($arrayOfUsers)->each->methodOnUserModel()

LazyCollection::make(function() {while(){yield $something})->
Model::cursor() returns a lazy collection of the model
$lazyCollection->takeUntilTimeout(now()->addMinute()) / keep processing generator for one minute. Esp useful for crons
tapEach / lazy version of each
$lazyCollection->remember(); $lazyCollection->take(5); $lazyCollection->take(20); / will take different 20

Contracts
---------
Interfaces that define core frmaework services e.g. Queue, Mailer, etc.
Each interface has an implementation provided by Laraval
A main use case for contracts is injecting laravel services without including Laravel framework (separate repo)
Esp. useful if creating PHP packages that laravel devs will use
Just type hint the contract instead of a service anywhere you'd normally use dependency injection

Events
------
Events in app/Events php artisan make:event SomeEvent
Listenersin app/Listener php artisan make:listener SomeListener --event=SomeEvent

$listner property in EventServiceProvider used to register [EventClass::class => [Listener1::class, Listener2::class...]]
can also manual register events in the boot method of the EventServiceProvider using Event::Listen
Can wrap manually registered events with the queueable function to use the queue
Can use wildcard to listen  like Event::listen('event.*', function (string $eventName, array $data) {///}});
Can also enable automatic event Listeners in config. Any listener class method starting with __invoke or Handle will be registered as an event Listener. Can type hint the event it handles.

Events are basically just classes that hold properties. They're containers.

Listeners can stop propgation by returning false from their handle method
To implement a queued listener (runs it's tasks off the queue), implement the ShouldQueue interface
For a queued listener, the event happens. Laravel dispatches the Listener onto the queue. In turn, it runs.
Can define $connection, $queue, and $delay as properties on the Queued Listener class
Can define a shouldQueue Method that will be called after the event to see if the Listener job should be added to the queue
If the InteractsWithQueue trait is used, the queue delete and release methods can be accessed in the Listener
If a queued listener is dispatched during a database transaction (e.g. inventory update). It's possibl the queued event listener (log imr), might happen before transaction closes. Can set after_commit to false to avoid this.
If the queued Listener fails the maximum number of attempts, the failed method on the listener class will be called
Can define the max number of tries or time-to-try-until ($now->addMinutes) on the queued listener as a property

Dispatch an event with SomeEvent::dispatch($args)

A subscriber is listener that defined a subscribe method with a Dispatcher $events argument.
It listens to multiple events, each like $events->listen(FirstEvent::class, [$this, 'someMethodName']);
Laravel can also infer the relation from an array returned by the subscrib emethod like return [Event1::class => 'insideMethodName', Event2::class => 'insideMethod2Name', ...]
Add the event subscriber to the $subscribe array property on the EventServiceProvider

Event::fake will dispatch fire events for testing, but no listeners will respond inside that method
can use Event::assertDispatched(EventClass::class, $n=1) / $n is number of times
Can also pass a truth test closures to assertDispatched that takes the event to see e.g. did the $order have all it's items
Event::asertListener(Event::class, Listener::class)
Event::fake([Event1::class, Event2::class]) will only block/fake event listeners for those in the array. Can also do fake()->except([...])
Event::fakeFor(closure) / Will fake/block listeners inside the closure, but not after in the test

File Storage
------------
Config
the local file system stores relative to the root directory in config (storage/app)
the public file system is foe fiel that will be public (storage/app/public)
should symlink storage/app/public to public/storage using php artisan storage:link
A scoped file system automatically prepends a prefix. So like on s3, it can create a fake directory structure for videos/css/etc. without constants
Disk Instances
Storage::disk('some-disk')->someDiskMethod();
$diskStorage::build([...$runtimeConfig]);

Retrieving Files
Storage::get('someFile.jpg') / relative to root. Returns raw string
Storage::json('some.json') / retrieves decoded json
Storage::exists('file.jpg') / checks if it exists
Storage::missing('file.jpg') / checks if not exists
return Storage::download('file.jpg', $fileName, $header) / the users browser will automatically download the file
Storage::Url('someFile.jpg') / locally it will just give a relative /storage/someFile.jpg, but with s3 it can give asset url. can pre-define url in config
Storage::temporaryUrl('file.jpg', $now->addMinutes(1))  / create temporary url to object in s3. Probably to e.g. give user a download link while real is hidden?
Storage::temporaryUploadUrl('file.jpg', $now->addMinutes(1))) / create link to upload to s3 only. Usefulf in serverless env.
Storage::size('file.jpg') / size in bytes
Storage::lastModified('file.jpg') / unix timestamp
Storage::mimeType('file.jpg') / mime
Storage::path('file.jpg') / on s3 this give sthe path relative to the s3 bucket. For local filesystems, it will give absolute path

Storing Files
Storage::put('file.jpg', $contentsOrPhpResource) / stored relative to root. Returns false on failures
Can configure 'throw' => true to throw an exception on failed writes
Storage::prepend('file.log', 'Some text') or Storage::append('file.log', $otherText) / string to file
Storage::copy('old/file.jpg', 'new/file.jpg') or Storage::Move('old/file.jpg', 'new/file.jpg') / move or copy
Storage::putFile('photos', new File('/path/to/photo')) or Storage::putFileAs('photos', new File(...), 'fileName.jpg') / avoids allocating whole file in memory. Just streams bit by bit
$file = $request->file('name')->store('directory') / store user upload. Generated a unique id name. The path is returned. Same as putFile. $file also has original name and extension as properties (can be tampered)
files can be instructed to be stored on different disk in store / storeAs parameters
file visbilility can be set as 'public' to be publicly viewable in put / store: Storage::put('file.jpg', $contents, 'public'), $request->file('demo')->storePublicly(...)
For local files, storing publicly sets the permissions to be readable

Deleting Files
Storage::delete('fileName.jpg') or Storage::delete(['first.jpg', 'second.jpg', 'third.jpg'])

Directories
Storage::files('directory') / files in directory
Storage::allFiles('directory') / files in directory and subdirectories
Storage::directories($directory) / array of directories
Storage::alDirectories($directories) / array of directories and subdirectories
Storage::makeDirectory($directory) / make new directory
Storage::deleteDirectory($directory) / delete a storage directory
Testing
Storage::fake('fake-testing-directory') / test uploading files etc. to fake directory
Storage::disk('fake-testing-directory') / can then be used as the test file directory
By default the 'fake-testing-directory' and all files will be deleted after the tests run

Helpers
-------
Available Methods











