
Routing
-------
Required parameters {} can be type hinted to closure / controller
Parameters go  afte dependencies
Placing ? mark after parameter makes it optional. Need to define a default value then.
Can place validation constraints on parameters with ->WhereIn, WhereAlpha, where, etc.


Middleware, controllers, subdomains, route name prefix may all be grouped

Can inject a model like /{user), then function(User $user)
{post:slug} will use slug property
Laravel automatically uses implicite relation in /{user}/{post:slug} bc :slug part. can turn this on / off

Can globally define custom model binding resolution logic, bind at the top of the routeserviceprovider bind
or resolveRouteBinding method inthe model.

ratelimiters exist.

forms are always POST
but then @method('PUT')
Route::current()

Middleware
----------
Putting code after $next($request) performs the middleware after the request has been handled
Add middleware in Kernel property or on routes
Middleware can be added to groups, with exceptions
Middleware can be aliased
May need to sort middleware priority by adding property in Kernel.
Can pass parameters to middleware like Route::get(...)->middleware('some-middleware-alias:parameter1,parameter2,parameter3')
Using FastCGI, a middleware can add a 'terminate' method called after the server sends the response. Useful for things like queueing jobs
If a middleware is not registered as a singleton, the terminate and handle methods will receive different instances of the middleware

CSRF
----
CSRF ex. is when user is logged into your site, visits another, then a form submits to e.g. change the user's passwords to the hackers
CSRF token makes sure the request comes from your site.

Controllers
-----------
Can create a single action controller using __invoke magic method
Can also specify middleware for a controller in the constructor like $this->middleware('example-middleware');
Can also define that middleware directly by using a closure
php artisan make:controller ExampleController --resource --model=Example
API resource controllers exclude the html form routes
Can create "nested" resource routes with dot notation 'User.comments', which generate urls like /user/{user)/comments/{comment}
Can change parameter labels in rouce routes with ->parameters(['example' => 'new-example']);
To override or create additional routes on resources, place them before the resource controller
A singleton resource controller is for something like a profile that only has one thing.
Can also build singleton like Route::singleton('photos.thumbnail', ThumbnailController::class);
Can make singleton ->creatable();

Requests
--------
$request->routeIs([name or wildcard matching route path])
$request->url() or $request->fullUrl(); depending on query string or not
can also retreive headers, scheme, host, ip, etc.
$request->input('name', 'Calvin') gets user-input value for name regardless of http verb
Can use dot notation for nested forms
$request->query does same for querystring
$request->boolean is useful for turning "true" or "on" from a checkbox into a true or false
$request->date()
$request->has() can be used to check if the user input is present in the request
-$request->flash() will flash the user input to the session, also redirect()->route('route-name')->withInput()
-$request->old('some-value') will then get the previously flashed data from the session
$request->cookie('some-cookie') does the obvious
$request->file('example')
->isValid()
->path()
->extension()
->store('s3' or 'images') etc.

Responses
---------
Can return string, array or Eloquent Collection and laravel will convert to html, json or json response, respectively
$response->cookie() sets cookie
all cookies ar eencrypted by middleware by default
back() will redirect back to last route
redirect()->route('this.is.for.a.named.route')
Can pass a eloquent model to a parameter e.g. route('picture', Picture)
redirect()->away('google.com') will redirect to external site
Can use with and withinput to flash session data to redirect response
can use view with response()->view('index', $data, 200)->header(...) to specify a view response but also set headers
response()->json([...])
response()->download($pathToFile)
response()->streamDownload(...) takes a string response and returns a download response. So, e.g. return a file from another website to the user without evber saving it to server disk
response()->file($pathtoFile) is like download but instead of downloading, it will just display in the browser (think pdf labels)

View
----
If in normal directory location, can alias view in response with like 'example.blade.php' => 'example'
Can share context across all views with the View::share('key', 'value') from within service provider
Can share context across specific views with a view composer
Facades\View::composer('example-blade-view', ExampleCreatedComposerClass::class)

Blade
-----
Can put any php inside curly braces {{ phpinfo() }}

un-escape html by {!! $htmlString !!} - for. ex. if storing html in database
@{{ $withAtSign }} will be ignored by blade. Useful for writing vue/react
@@if() will also be rendered directly as @if
@verbatim will escape large blocks of js
{!! json_encode($array) !!} is like {{ Js::from($array) }} (!! means don't want {'example': '<something>'} to be converted to {'esxmple': '%27something%28'}

@if (count($record) === 1) example @elseif (count($record) > 1) example2 @else example-1 @endif
@isset($variable) something @endisset
@empty($records) something not @endempty
@auth @endauth checks if user is authenticated
@guest @endguest checks if not authenticated
@auth('admin')@endauth checks specific uathentication guards
@env(['prod', 'test']) checks environemtn
@hasSection('nav')<h1>hello</h1>@endif only inserts if the template inheritance 'nav' has content
@sectionMissing does opposite
@switch($i) case(1)asdff @break case(2)asd@break @default asss @endswitch
@for($i = 1; $i < 10; ++i) soemthing @endfor
@foreach($users as $user) {{ $user->id }) @break($user->id == 27) {{ $loop->index }} @continue @endforeach
@while ($i) {{ --$i; }} @endwhile

<span @class([
    'red' => $isRed,
    'blue' => $isBlue,
    ])

    @style([
    'background-color: green' => $isGreen
    ])
    >some text</span>
@checked($isChecked)
@selection($isSelected)
@disabled($isDisabled)
@readonly($isReadOnly)
@required($isRequired)

<div> @include('some.child', ['additional-context' => 4]) </div> some.child will inherent all parent data
@includeWhen($ifTrue, 'some.child' , ['addtl' => 3])
@each('view.name', $someArray, 'iteratorVariableName') will render view.name for each entry in $someArray

@php $i = 1; @endphp
{{-- comment --}}

Class based components and anonymous components
php artisan make:component Alert
app/view/Component/Alert.php + resources/views/components/alert.blade.php
php artisan make:component Alert --view creates an anonymous component, that means it has no class jsut a blade resource
<x-alert>
<x-alert type="error" :message="$message"> will pass $type = 'error'; $message = $message; to the
__construct(public string $type, public string $message) constructor
{{ $message }} can render variable inside componeent
can also write <x-alert :message>
<x-button ::class="something"> -> <x-button :class="something"> Can use :: to escape things that shouldn't be passed (like vue attributes)
can call public class methods (.e.g public function isSelected() ...) like <option {{ $isSelected($value) ? 'selected' : ''}}></option>
Component class render method can return a closure that will receive the component name, attributes and slot as an array : return function (array $data) {// $data['componentName']; $data ['attributes']; $data['slot']; return '<div>something</div>'; };
The compnent render method should either return the string name of a blade view or the inline contents to be evaluated as a blade view
any html attributes specified in the component tag are passed through the component class to the rendered blade via a "attributes" variable
<x-alert class="mt-4"> --> <div {{ $attributes }}>Rendered component</div> would have a class="mt-4"
Can merge and conditionally merge attributes using methods on the attributes variable
{{ $slot }} in the implementation will render whatever is placed inside the component tag. Can define-multiple by <x-slot:some-name>
<x-alert>
<div class="alert">
<h1 {{ $title->attributes }}>{{ $title }}</h1>
<div>{{ $slot }} </div>
</div>
</x-alert>
called with <x-alert ><x-slot:title class="h1">Warning</x-slot> This is then the slot</x-alert>
Can use {{ $component->someComponentClassMethod('asdf') }} inside a scoped slot
Notice $title->attributes above for passing in attributes to a scoped slot
Can directly return the component markup from the render method on component class to avoid creating separate blade view
An anonymous component has no class. Useful if I want to be able to just include a subview in blade without an include
Can use an index.blade.php vile inside a subdirectory to be able to use something like
<x-accordian> // index
<x-accordian.item>slotted info</x-accordian.item>
</x-accordian>
In an anonymous component, can specify @props['propName1', 'propName2']) to specify which should be treated as props (vs. attributes)
Can pass child components parent props with @aware(['propName1'])
Generally define one parent layout <x-layout>, then use that as "body" in most components

@csrf
@method
@error('validationBagName') acts as a conditional if
@push('scripts')<script src="/example.js"></script>@endpush -> $stack('scripts')
@prepend is like push, but at beginning
@inject('alias', 'App\Services\SomeService') --> {{ $alias->getMethod() }}

Fragments can be used to only render part of a view
@fragment('top-of-packing-slip')<img>@endfragment
return view('some-view-that-has-multiple-fragments')->fragment('top-of-packing-slip');

Can register custom blade directives using Blade::directive('alias', closure) inside boot method of app service providers
Blade::stringable allows overriting representation of {{ $object }} from __toString() to something custom

Asset Bundling
--------------
Vite rewrites relative urls to a bundled asset
Vite leaves absolute paths untouched. These should reference assets already in the public folder
Can automatically import resources in resources/images and resources/fonts by addin tto resources/js/app.js:
import.meta.glob(['../images/**', '../fonts/**'])
<img src="{{ Vite::asset('resources/images/logo.png') }}">
Vite dev server can automatically refresh browser when certain file paths are changed. Meh.
Vite::macro('image', fn(string $asset) => $this->asset("resources/images/$asset") -> <img src={{ Vite::image('logo.png') }}">
prepending VITE_ to env variable will inject it into js
import.meta.env.VITE_SOME_ENV_VAR to access
can set nonce on csp to prevent running outside scripts

URL Generation
--------------
url("/posts/1"); --> https://www.calvinhill.com/posts/1
url()->current()
->full() // include query string
->previous() // last request
can also use facade URL::full()
route('named.route') is like url for a .. named route // useful if routes change, which they do
route('named.route', ['post' => 1])
route('named.route', ['post' => $post])
URL::signedRoute('unsubscribe', ['user' => 1]) // includes a hash in the querystring. Only user 1 can use this to unsubscribe
URL::temporarySignedRoute(...) // expires after awhile
For a signed route need to use $request->hasValidSignature() in the action
Can also validate signature in middleware
action([SomeController::class, 'actionMethod']) // like url or route, but for Controller action

Session
-------
file session driver is default
Redis is useful when moving past one server
php artisan session:table can create migration to setup db for handling sessions

$val = $request->session()->get('key', 'defualt'); // or $request->session()->all()
$request->session()->put('key', 'value');
$request->session()->push('key', 'value2'); // this would append 'value2' if 'key' pointed to an array value

$val = session('key');
session(['key' => 'value']); // can set a key=>val in global session

$request->session->flash('key', 'value') -> available for next request, things like error messages
$request->old('key') will retrieve flash

can block certain session url endpoints to avoid concurrency bugs

Request validation
------------------
(in controller) $request->validate(['title' => 'required|unique:posts:max:255']); // will automatically redirect to last route if not successful
if the request is xhr, instead of a redirect, it will return a json response with the error
Can also delimit rules as an array: ['required', 'unique:posts', 'max:255']
if using ['bail', 'rule1', 'rule2'] rule2 won't be evaluated if rule 1 fails
can specify a nested form field with 'parent.child'
middleware automatically passes the errors to the view @errors->all()
$request->old('title') will get error from last request aka <input value="{{ old('title') }}>
often need to add nullable to validated optional fields e.g. 'publish_at' => 'nullable|date', because null gets converted to empty string by convertEmptyStringsToNull middleware which is not a valid date

php artisan make:request StorePostRequest // a form request
has two methods: authorize and rules
typehint the request passed to the controller like public function store(StorePostRequest $request) {} // validation is handled automatically
can add an "after" method to the form request to perform further validation after the other validation is complete
the after methods can return an array of classes with the __invoke method defined.
can customize the redirect location
can customize the error messages e.g. 'title.required' => 'The title is required'
can modify data before validation with prepareForValidation() method, e.g. lowercasing, trimming, escaping, etc.
can also normalize data after passing validation before with passedValidation() being sent to the controller
with multiple forms on a page, each form's message bag can be named to put the errors on the right form

Can manually make a validator, but imo, better to either use standard request validator or make a form validator

$validated = $request->validated();
$validated = $request->safe()->all() or $request->safe()->only(['title']) or $request->safe()->except('title')
foreach($request->safe() as $eachSafe) ... // as an array

interesting validation rules:
distinct 'users.*.id' // array of user ids are all unique
starts_with end_with// check the a string start or ends with some other
between:min,max // supports strings, numberics and files
active_url // checks dns records at runtime
alpha_num // several variations
different:field // make sure this is different than another field
exclude // remove this value from validated results (unmapped)
exists:table,column // 'state' => 'exists:states' will check if the input string exists in the 'state' column of the 'states' db table
image // checks file type
regex:pattern
unique:table,column // reverse of exists, can be used with ignore to allow user to change their email but not to another user's email

$validator->sometimes(...) to specify a closure for when to add a field
if validating arrays, always specify which array keys are allowed 'user' => 'array:username, locale'
when validating array, the error message can include the index position with 'Please fix :position'

Laravel has a oop file validator for specifying file validation. Same functionality as above approach
It also has custom password validator that can check length/symbols and whether it's been compromised in a breech

Can create a validation rule and pass it as a class to an array of validation rules

An implicite rule ONLY implies that an attributes is required (the custom validation rule will run). If empty data is not allowed -> the rule should fail

Error handling
--------------
Can add closures to App\Exceptions\Handler->register() $this->reportable method
The type hint to each closure says which type of exceptions the closure should intercept
Can add ->stop to prevent Laravel doing it's normal stuff on customly handled exceptions
Can define custom context to each exception in the context method
Define per exception context on the exception class context method e.g. order Id of invalid order
report($exception) can be used in catch block. It logs the exception but allows the request to continue
the $levels property maps each Exception class to a Psr\Log\LogLevel
By default, Laravel generates an error response for unhandled exceptions. This can be over-written/modified
Defining report and render methods on the custom Exception will cause these to be used
abort(404) (or other code) generates a response corresponding to that http error code
can customize blade views for each error view with resources/views/errors/404.blade.php

Logging
-------
the default logging is "stack", which aggregates all the logging channel into the "single" log
The single log is one file written to disk.
Another common setup is daily, where logs are written to a separate file each day
Can configure logging deprecation warnings
A common approach with "stack" logging is to aggregate multiple log channels in one, then have each channel define which severity level it logs

Log::emergency($message)  // alert - debug - critical - error - warning - notice - info - debug
Log::emergency($message, ['user' => $user->id])
Log::withContext(['request-id' => (string) Str::uuid()]) will force all subsequent log entries in a particular channel to include the request id
To share across all channels use Log::shareContext(['request-id' ...])
Log::channel('non-default-channel')->emergency($message)
Can define runtime on-demand channel using Log::build(['path' => some_custom . $var . '.log'])

Can customize Monolog instance by defining a 'tap' property that defines an invokable class that can modify it

Most monologue formatting is done by specifying a handler e.g. SlackHandler then setting the configurating via logging.php that would be passed to it's constructor
In particular, can pass the formatter and 'formatter_with' to specify how log entries should be written

Commands
--------
php artisan list // shows all commands
php artisan help migrate // shows help for migrate command
php artisan tinker // laravel aware shell
php artisan make:command SomeCommand
inside routes/console.php can use the Artisan::command(...) method to register closure-based commands
a command can implement the Isolatable contract to ensure only one instance runs at a time

An argument is specified without any key.
Can define arguments in the signature: protected $signature = 'mail:send {user}'; // {user?} or {user=foo} like route params

An option is specified with a double hyphen
A signature can define a "switch" option that takes no value like {--send-immiediately} // -- is the syntax
A signature can define an option with a value using {--send-after=} // the syntax is --XXXX=
An option with a value can define a default like {--send-after=300000}
$signature = 'mail:send {user?*}' can accept zero (* means optional) or many space-separated values (*) // both arguments and options
Array inputs should be passed like php artisan mail:send user=1 user=2 user=3 user=4
Can define a description of an input after a spaced colon: {user?* : the id of a user}
Can access arguments and options with $this->arguments() and $this->options()

Can ask user for input using $var = $this->ask or ->secret // Secret will hide their e.g. password response
Can ask for confirmation with $this->confirm(...)
Autocomplete with $this->anticipate('Today is ...', ['Mon', 'Tue', 'Wed']);
$this->choice('question?', [1, 2, 3], $defaultIndex, $maxAttempts, $allowMultipleTries);
Can output variables with $this->line(...) | info | comment | question | warn | error
$this->newLine($x) will output $x newlines
$this->table(['first', 'last'], $arrayOfFirstAndLastNames) outputs a formatted table
$this->withProgressBar($array, closure()); will show what % of $array the closure has been performed on

Artisan::call('some:commad', [...$args]) to call a command outside artisan
can also use Artisan::queue to run it programmatically using the queue
Inside a command, can use $this->call(...) or $this->callSilently(...) // call silently suppresses output

Can use $this->trap(SIGTERM, closure); // where SIGTERM is an OS signal to define how a command should handle signals inside the handle method

Broadcasting
------------
Clients side js connects to named channels and laravel broadcasts events to them
Not going to read this because it's tied to commercial vendors.
There is one open source option

Cache
-----
Cahing is for storing data that will be used again and took awhile to compute
php artisan cache:table generates a migration for using the db as a cache
Usually use memcached or redis
Cache::get('key', 'default') // default value is optional, otherwise null is returned
Cache::store('some-store')->get('key')
$value = Cache::remember('users', $timeValueInSeconds, fn () => {return $val;} // Either gets the value from the cache or runs the closure and sets the cache value to the var
Cache::rememberForever doesn't expire
Cache::put('key', $val, $seconds) // $seconds is optional
Cache::add('key', $val, $seconds) will only put the value if it doesn't exist, but it's atomic
Cache::forget('key')
Cache::flush() // remove all

cache('key') // Cache::get
cache('key', 'val', $seconds) // Cache::put
cache()-> // Same as Cache::

Cache tags allow "grouping" cache keys by assigning them tags
Cache::tags(['people', 'artists'])->put('John', $john, $seconds);
Cache::tags(['people', 'artists'])->get('John'); // cannot retrieve john w/o Tag. almost like 'people.john' key
Cache::tags(['people'])->flush()

Using Redis, php artisan cache:prune-stale-tags should be scheduled on a cron

$lock = Cache::lock('key', 10);
if ($lock->get()) { ; ; ; ; $lock->release();} // attempts to get lock, which is when the timer starts
$lock->get can also take a closure and release the lock after the closure finishes
$lock->block(5) will try to get the lock, if it fails it will keep trying for 5 s before throwing an exception

a $lock has an ->owner() that can be used to restore a lock in another process, then release it
This is useful for e.g. dispatches a queue job in a web request, then releasing lock after queue job

Collections
-----------
An attempt to gloss over php array function confusion
Eloquent queries always return a collection
collect($someArray)
generally, each collection method returns a new collection

Collection::macro('alias', closure) --> collect($someArray)->alias() // should be declared in boot method of a service provider
Additional arguments to the macro like fn($something) can be passed collect($someArray)->alias('something')

all() / returns array from collection
avg('some-key') / returns average value of 'some-key' in each sub-array. On a flat array, returns average
chunk(2) / [1, 2, 3, 4] -> [[1, 2], [3, 4]]
chunkWhile(fn (string $value, int $key, Collection $chunk) {// when to chunk})
collapse / flatten nested
collect($collection) / convert lazy collection into normal collection
(collection(['first', 'second']))->combine([1, 2]) / ['first' => 1, 'sedcond' => 2]
concat / starts with a collection, takes another array or collection, reindexes the keys in both in order, then concats second to first
contains / check if string/('key', 'value')/ closure evaluating to true exists
containsOneItem / count() ==  1
containsStrict / like contains but uses strict comparison
count / count
countBy() / either a function or like [1, 1, 1, 2, 2] => [1 => 3, 2 => 2]
crossJoin / ['a', 'b'] => [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
dd / debugging. Prints items and stops script
collection([1,2,3,4]->diff([1,2]) / values in original collection not in passed [3,4]
diffAssoc / like diff, but for (key,value) pairs in associative array
diffKeys / like diff associ but will remove original keys even if the value is different
doesntContain / opposite of contains
dot / ['top' => ['nestted' => ['key' => 'value']]] => ['top.nested.key' => 'value']
dump / output key / values in collection
duplicates() / returns duplicated values from an array [1, 2, 2, 3] => [2]
duplicates('some-key') / returns duplicate values for key [['test' => 1], ['test' => 1], ['prod' => 2]] => ['test' => 1]
duplicatesStrict / like duplicates but uses strict comparison
each() / like map, passes each collectio item into aclosure. Map collects the return responses through
eachSpread / expands each nested item in a collection and passes it as parameters to a closure e.g. ['Calvin', 'Arthur', 'Hill'] -> fn ($firstName, $middleName, $latName) {}
every() / does every value in a collection pass a truth test [2,4,6] => fn($val, $key) {return $val %2 == 0} -> true
except / filter specified keys out of a collection
filter() / keep only items that pass a truth test
first() / first item in collection that passes a truth test
firstOrFail / like first, but if none are found, throw an exception
firstWhere / in a nested array, find the first item containing a key/val pair. In a flat, can pass in a comparison opeerator (> 18)
flatMap / runs a closure on each item in array then flattens the result one level. Useful if the map returns a string explosion
flatten / flattens to a single dimension, or if an arg is passed, flatten that number of "depths". [[[1,2,3]], [4,5,6]] => [1,2,3,4,5,6]
flip / switch keys and values
forget('key') / remove key/value pair with given key. Operates in place (not immutable)
forpage($pageNumber, $itemsPerPage) / returns a collection showing items projected to be on page e.g. collection([1,2,3,4,5,6,7,8])->forPage(2,3) -> [4,5,6]
get('key') / return value of given key or null or default
groupBy / [['first' => 'Calvin', 'last' => 'Hill'], ['first' => 'Calvin', 'last' => 'Coolidge'], ['first' => 'George', 'last' => 'Washington']] ->groupBy('first') =>  ['calvin' =>  [['first' => 'Calvin', 'last' => 'Hill'], ['first' => 'Calvin', 'last' => 'Coolidge']], ['George' => ['first' => 'George', 'last' => 'Washington']]]  Can also group by multiples
has('key') / does key exist in collection
hasAny(['key1', 'key2', 'key3']) / has but for array of keys
implode('key', ',') or implode(',') or implode(transorm-closure(), ',') / join items in collection into string
intersect() / filter any items in first collection not present in second. Maintains key position
intersectAssoc() / return key value pairs present in all collections
intersectByKeys() / return collection of key value pairs from the original collection that have matching keys in the passed collection
isEmpty() / count(0)
isNotEmpty
join(',') / joins values into string. Can pass a second parameter for last delimeter
keyBy() / [['first' => 'Calvin', 'last' => 'Hill'], ['first' => 'Calvin', 'last' => 'Coolidge'], ['first' => 'George', 'last' => 'Washington']] -> keyBy('first') -> [['first' => 'Calvin', 'last' => 'Coolidge'], ['first' => 'George', 'last' => 'Washington']]
keys() / return all keys in collection
last() / last element that passes a truth test or w/o a closure, that last overall
lazy() / return lazy collection from collection. $bigCollection->lazy()->where()->where()->count() // only original collection in memory. The generated ones basically "flip" in place
macro() / add methods to collection class at runtime
make() / create a collection from an array Collection::make($someArray)
map() / run closure on each item then takes the return values into a new collection
mapInto() / use passed class constructor as map function
mapSpread() / pass nested collection into callback as expanded e.g. [[1,2,], [3,4]] -> fn($odd, $even)
mapToGroups / callback function should return array. The final collection will group by the keys in the callback-returned array
mapWithKeys / like mapToGroups but the result won't be 'key' => [$val1, $val2, $val3...], but 'key' => 'val'
max('key') / max val for key in nested collection. Without a key, it will just give highest value
median / median value for key, or without a key, median of all values
merge / merge given collection with original. The passed collection keys will over-write existing original. Numeric keyed collections will  be appended.
mergeRecursive / like merge, but instead of over-writing the multiple values are put in to a sub array. e.g. collection(['key' => 1])->mergeRecursive(['key' => 2])  -> ['key' => [1,2]]
min / like median or max
mode / like min
nth(4) / like if index % 4. Takes every 4th element. Can pass an optional offset
only / filter any items in collection that don't have the given keys
pad(items, $value) / will fill array with $val until it reaches the desired # of items. If negative it will pad to the left until count() ==  abs($items)
[$passes, $fails] = partition(truthinessClosure) / breaks into those that pass and those that don't
pipe(closure) / passes collection itself to this closure
pipeInto(ClassName::class) / passes collection into constructor of class
pipeThrough / like pipe but passes through multiple closures like ->pipe(fn($collection){})->pipe(fn($results){})...
pluck('key') / return collection containing all values in nested collection for a particular key. Can optionally pass another key, whose value will  be used as the key for each value in the result
pop() / last item from the collection
prepend / add item to start cof collection
pull('key') / remove item from collection with key 'key' and return it: ['key' => $val]
push() / append item to end of collection
put('key', 'value') / sets key-val in collection
random() / random item from collection. Can pass optional number of random items to return
range(2,6) / [2, 3, 4, 5, 6]
reduce(function (?int $carry, $value, $key) {}) /  reduce function
reduceSpread(fn($carry, $arrayCarry, $currentValueFromCollection){ // return [$newCarry, $newArrayCarry];}, $originalCarry, $originalArrayCarry) / Like reduce, but operates on an array carry that is passed through each iteration
reject(function truthCallback($key, $value){}) / if truthCallback returns true the item is filtered from the collection
replace / like merge but over-writes both string and numeric e.g. collect(['first', 'second'])->replace([1 => 'third']) -> ['third', 'second']
replaceRecursive / like replace, but you can pass nested array structure like 2 => [1 => 'King'] and end up with ['asdf', 'asdf2', ['asdf3', 'King']]
reverse / reverse the order of the collection, maintaining keys -> [4 => 'last' ... 1 => 'first']
search(4) / return key of item with given value
shift($n=1) / remove and return first $n collection items
shuffle() / randomly change order of collection
skip($n) / return new collection with first $n items removed
skipUntil(truthClosure) / return all items from front of collection until truthClosure returns true. Can also pass value e.g. skip all values until $value==3
skipWhile / opposite of skipUntil
slice($start, $size) / returns items between indexes $start and $start + $size
sliding($newCollectSize, $stepSize) / take chunks of collection in size $size [1, 2, 3, 4, 5, 6] -> [[1, 2], [2, 3], [3, 4], [4,5], [5,6]]
sole / like first but only returns if the item is the only in the collection that passes the truth test. Without arguments it will return the item only if it is only in the collection
some / alias for contains
sort / maintaining keys, sort the array. So [4,3,2,1] -> [3=>1, 2=>2, 1=>3, 0=>4]. Can use ->values() to re-key. Can take callback
sortBy('key') / sort by given key, callback or array of sort operations [['name', 'asc'], ['age', 'desc']]. can accept sort flags to define numeric, string, etc. comparator
sortByDesc / sortBy in opposite order
sortDesc / sort in opposite order
sortKeys / sort by keys
sortKeysDesc / sort by keys in opposite direction
sortKeysUsing($callBack) / sort by keys using provided comparison  callback returning an integer lt, et, gt zero
splice($startIndex, $numberOfItem, [$replaceWith..]) / remove items from array (and optionally replace with provided) and return the new collection. Mutator
split(3) / split collection into 3 groups
splitIn(3) / split but only the last group can be smaller so [1,2,3,4,5,6,7,8,9,10]->[[1,2,3,4], [5,6,7,8], [9,10]] instead of [1,2,3,4], [5,6,7], [8,9,10]
sum() / sum all items in collection. Or values of passed key argument.
take($n) / if positive, first $n items of collection. If negative, last abs($n) items of collection
takeUntil() / either take until a truth condition passes or if passed a value, until that value is encountered
takeWhile() / reverse of take until
tap / pass collection to closure, but then it returns the original collection. Useful for e.g. chaining log dispatch
Collection::times($n, closure($i) / create new collection by calling closure $n times
toArray / turn collection back into plain array
toJson / turn collection into json serialized string
tranform / call callback on each item in collection and replace the current item with the result. Mutable. Replaces in-place
undot / collect(['dot.foo' => 1, 'dot.bar' => 2, 'dot.baz' => 3])->undot() -> ['dot'  => ['foo' => 1, 'bar' => 2, 'baz' => 3]]
union / combines original collection with a given array. The original items will be preferred
unique / return only unique values. keys are maintained. Can pass a key to determine uniqueness e.g. one person of each age in census data
uniqueStrict / like unique but uses strict comparison. Means it can return like [1, '1']
unless(boolean $true, ifNotTrueCallback, ifTrueCallback) / opposite of when. Calls the first callback on the collection if the first arg is false. If the first arg is true (optioanlly) calls second callback
Collect::unwrap() / given an array or collection, returns an array. Given a primitive, returns a primitive
value / return value of key from first item in collection collection([['first' => 'Calvin'], ['first' => 'Jake']])->value('first') -> 'Calvin'
values() / reset collection keys to consecutive 0-indexed integers
when(bool $truthValue, callback, callback) / when truthValue, pass collection to first callback. Otherwise (optionally) pass it to the second
whenEmpty(callback, optionFallBackCallback) / if the collection is empty, pass it  to the first Callback, otherwise (optionaly)the second
whenNotEmpty / like whenEmpty
where('price', '==', 100) / Second paramter is optional. Defualts to '==', can pass most '<=', '<', etc. operators. [['price' => 100, 'name' => 'Apple'], ['price' => 101, 'name' => 'Samsung']] => [['price' => 100, 'name' => 'Apple']]
whereStrict / can just change operator, which is shorter and more explicite
whereBetween('key', [$start, $end]) / like where but for double comparison
whereIn('key', [$opt1, $opt2, $opt3]) / like where, but the collection value for key has to equals one of the options
whereInStrict( / see whereStrict
whereInstanceOf(ClassName::class) / filter collection items that aren't of type ...
whereNotBetween / like whereBetween
whereNotIn / like whereIn
whereNotInStrict / where items with key 'key' are not strictly equal to one of the values passed
whereNotNull / filters keys with null values
whereNull / only returns keys with null values. Could also use where('key', '===', null)
wrap / creates a collection from primitives, arrays or existing collections
zip / (collect(['first', 'last'])->zip(['Calvin', 'Hill']) -> ['first' => 'Calvin', 'last' => 'Hill']

higher order messages: can use certain common collection methods as properties like collection($arrayOfUsers)->each->methodOnUserModel()

LazyCollection::make(function() {while(){yield $something})->
Model::cursor() returns a lazy collection of the model
$lazyCollection->takeUntilTimeout(now()->addMinute()) / keep processing generator for one minute. Esp useful for crons
tapEach / lazy version of each
$lazyCollection->remember(); $lazyCollection->take(5); $lazyCollection->take(20); / will take different 20

Contracts
---------
Interfaces that define core frmaework services e.g. Queue, Mailer, etc.
Each interface has an implementation provided by Laraval
A main use case for contracts is injecting laravel services without including Laravel framework (separate repo)
Esp. useful if creating PHP packages that laravel devs will use
Just type hint the contract instead of a service anywhere you'd normally use dependency injection

Events
------
Events in app/Events php artisan make:event SomeEvent
Listenersin app/Listener php artisan make:listener SomeListener --event=SomeEvent

$listner property in EventServiceProvider used to register [EventClass::class => [Listener1::class, Listener2::class...]]
can also manual register events in the boot method of the EventServiceProvider using Event::Listen
Can wrap manually registered events with the queueable function to use the queue
Can use wildcard to listen  like Event::listen('event.*', function (string $eventName, array $data) {///}});
Can also enable automatic event Listeners in config. Any listener class method starting with __invoke or Handle will be registered as an event Listener. Can type hint the event it handles.

Events are basically just classes that hold properties. They're containers.

Listeners can stop propgation by returning false from their handle method
To implement a queued listener (runs it's tasks off the queue), implement the ShouldQueue interface
For a queued listener, the event happens. Laravel dispatches the Listener onto the queue. In turn, it runs.
Can define $connection, $queue, and $delay as properties on the Queued Listener class
Can define a shouldQueue Method that will be called after the event to see if the Listener job should be added to the queue
If the InteractsWithQueue trait is used, the queue delete and release methods can be accessed in the Listener
If a queued listener is dispatched during a database transaction (e.g. inventory update). It's possibl the queued event listener (log imr), might happen before transaction closes. Can set after_commit to false to avoid this.
If the queued Listener fails the maximum number of attempts, the failed method on the listener class will be called
Can define the max number of tries or time-to-try-until ($now->addMinutes) on the queued listener as a property

Dispatch an event with SomeEvent::dispatch($args)

A subscriber is listener that defined a subscribe method with a Dispatcher $events argument.
It listens to multiple events, each like $events->listen(FirstEvent::class, [$this, 'someMethodName']);
Laravel can also infer the relation from an array returned by the subscrib emethod like return [Event1::class => 'insideMethodName', Event2::class => 'insideMethod2Name', ...]
Add the event subscriber to the $subscribe array property on the EventServiceProvider

Event::fake will dispatch fire events for testing, but no listeners will respond inside that method
can use Event::assertDispatched(EventClass::class, $n=1) / $n is number of times
Can also pass a truth test closures to assertDispatched that takes the event to see e.g. did the $order have all it's items
Event::asertListener(Event::class, Listener::class)
Event::fake([Event1::class, Event2::class]) will only block/fake event listeners for those in the array. Can also do fake()->except([...])
Event::fakeFor(closure) / Will fake/block listeners inside the closure, but not after in the test

File Storage
------------
Config
the local file system stores relative to the root directory in config (storage/app)
the public file system is foe fiel that will be public (storage/app/public)
should symlink storage/app/public to public/storage using php artisan storage:link
A scoped file system automatically prepends a prefix. So like on s3, it can create a fake directory structure for videos/css/etc. without constants
Disk Instances
Storage::disk('some-disk')->someDiskMethod();
$diskStorage::build([...$runtimeConfig]);

Retrieving Files
Storage::get('someFile.jpg') / relative to root. Returns raw string
Storage::json('some.json') / retrieves decoded json
Storage::exists('file.jpg') / checks if it exists
Storage::missing('file.jpg') / checks if not exists
return Storage::download('file.jpg', $fileName, $header) / the users browser will automatically download the file
Storage::Url('someFile.jpg') / locally it will just give a relative /storage/someFile.jpg, but with s3 it can give asset url. can pre-define url in config
Storage::temporaryUrl('file.jpg', $now->addMinutes(1))  / create temporary url to object in s3. Probably to e.g. give user a download link while real is hidden?
Storage::temporaryUploadUrl('file.jpg', $now->addMinutes(1))) / create link to upload to s3 only. Usefulf in serverless env.
Storage::size('file.jpg') / size in bytes
Storage::lastModified('file.jpg') / unix timestamp
Storage::mimeType('file.jpg') / mime
Storage::path('file.jpg') / on s3 this give sthe path relative to the s3 bucket. For local filesystems, it will give absolute path

Storing Files
Storage::put('file.jpg', $contentsOrPhpResource) / stored relative to root. Returns false on failures
Can configure 'throw' => true to throw an exception on failed writes
Storage::prepend('file.log', 'Some text') or Storage::append('file.log', $otherText) / string to file
Storage::copy('old/file.jpg', 'new/file.jpg') or Storage::Move('old/file.jpg', 'new/file.jpg') / move or copy
Storage::putFile('photos', new File('/path/to/photo')) or Storage::putFileAs('photos', new File(...), 'fileName.jpg') / avoids allocating whole file in memory. Just streams bit by bit
$file = $request->file('name')->store('directory') / store user upload. Generated a unique id name. The path is returned. Same as putFile. $file also has original name and extension as properties (can be tampered)
files can be instructed to be stored on different disk in store / storeAs parameters
file visbilility can be set as 'public' to be publicly viewable in put / store: Storage::put('file.jpg', $contents, 'public'), $request->file('demo')->storePublicly(...)
For local files, storing publicly sets the permissions to be readable

Deleting Files
Storage::delete('fileName.jpg') or Storage::delete(['first.jpg', 'second.jpg', 'third.jpg'])

Directories
Storage::files('directory') / files in directory
Storage::allFiles('directory') / files in directory and subdirectories
Storage::directories($directory) / array of directories
Storage::alDirectories($directories) / array of directories and subdirectories
Storage::makeDirectory($directory) / make new directory
Storage::deleteDirectory($directory) / delete a storage directory
Testing
Storage::fake('fake-testing-directory') / test uploading files etc. to fake directory
Storage::disk('fake-testing-directory') / can then be used as the test file directory
By default the 'fake-testing-directory' and all files will be deleted after the tests run

Helpers
-------
Arrays and Objects
Arr::accessible($something) / does $something['key'] make sense
Arr::add($array, $key, $value) / if key is not set or existing key val is null, add new val
Arr::collapse([[1,2], [3,4], [5,6]]) -> [1,2,3,4,5,6]
Arr:crossJoin([1,2], ['a', 'b']) -> [[1,'a'], [1, 'b'], [2, 'a'], [2, 'b']]
[$keys, $values] = Arr::divide(['name' => 'Calvin']) / $keys = ['name'], $values = ['Calvin']
Arr::dot(['foo' => ['bar' => 'baz']]) / ['foo.bar' => 'baz']
Arr::except($array, ['key1', 'key2']) / remove items with keys key1 and key2 from $array
Arr::exists($array, $key) / is $key in $array
Arr::first($array, $closure) / return first item in array passing closure
Arr::flatten($array) / ['key' => 'val1', 'nestedKey' => ['key2' => 'val2', 'key3' => 'val3']] -> ['val1', 'val2', 'val3']
Arr::forget($array, 'dot.notated.key') / ['key' => ['key2' => 'val']] -> forget($arr, 'key.key2') -> []
Arr::get($araray, 'dot.notated.key') / ['key' => ['key2' => 'val']] -> get($array, 'key.key2') -> 'val'
Arr::has($array, 'dot.notated.key') -> check whether dot notated key in array
Arr::hasAny($array, ['dot.notated.key', 'dot.notated.key2']) -> like has, but accepts an array of keys
Arr::isAssoc() / returns whether an array is associative (does NOT sequential numerical keys starting at zero)
Arr::isList() / boolean opposite of isAssoc
Arr::join($array, ',') / join array elements into a string
Arr::KeyBy($array, 'key') / [['key' => 1, 'key2' => 2], ['key' => 3, 'key2' => 4]] -> ['key' => ['key' => 1, 'key2' => 2], 'key' => ['key' => 3, 'key2' => 4]]
Arar::last() / last item in array passing  a truth test
Arr::map($array, $callback) / replace each array value with the value from the callback
Arr::mapWithKeys($arry, $callback) / callback returns [$key => $val] that replace each array items key and value
Arr::only($array, ['key1' ,'key2']) / returns only items in the array with the given keys
Arr::pluck($array, 'dot.notated.key') / [['dot' => ['notated' => ['key' => 1]]], ['dot' => ['notated' => ['key' => 2]]]] -> [1, 2] Can specify another 'dot.notated.key' as the key value
Arr::prepend($array, 'key', 'val') / ['key2' => 1] -> ['key' => 'val', 'key2' => 1]
Arr::prependKeysWith($array, 'prepend.') / ['key' => 1] -> ['prepend.key' => 1]
Arr::pull($array, 'name') / returns and removes 'name' key-value item from array. Can specify a default if key doesn't exist
Arr::query($array) / converts array into a query string
Arr::random($array, $n=1) / Either return single random value or if optional arg is passed array of $n random values
Arr::set($array, 'dot.notated.key', 20')  / [] -> ['dot' => ['notated' => ['key' => 20]]]
Arr::shuffle($array) / re-arrange array
Arr::sort($array) / sort by array values. Optionally pass a closure as second arg that returns value from each array to sort by.
Arr::sortDesc($array) / reverse sort
Arr::sortRecursive($array) / [['c', 'b'], ['b', 'a']] -> [['a', 'b'], ['b', 'c']]
Arr:toCssClasses($array) / takes an array of ['numeric-key-class', 'class-name' => $boolean-true, 'class-name2' => false] -> 'numeric-key-class class-name'
Arr::where($array, $closure) / filter $array to only items retuning true from closure
Arr::whereNotNull($array) / filter null values
Arr::wrap($someVar) / wraps $someVar in an array, if it is not alreayd an array. Null returns an empty array

data_fill($data, 'dot.notated.*.key', $value) / if the key doesn't exist in array. It will be set to $value. Can accept wildcards
data_get($array, 'dot.notated.*.key') / returns key value from the array, or array of values for wildcard. Can specify a default
data_set($array, 'dot.notated.*.key', $value) / set key to $value in array. Unlike fill, this will override. Can pass 4th arg as false to act like fill
head($array) / return first item in an array
last($array)/ retur nlast item in array

Paths
app_path() / returns fully qualified path to application app directory
app_path('Http/Controllers/Controller.php') / with an argument, returns a fully qualified path relative to the app directory
Similar functions for base | config | database | lang | public | resource | storage directories

Strings
__('some-string') / translates the give nstring using language files
class_basename(SomeClass::class) / returns the classname with the namespace removed
e('string') / runs php htmlspecialchars, escaping any special characters (like <div>) to %lt;...
preg_replace_array('/regex/', [$replacementValues...], $string) / run regex, replacing values sequentially using the replacement values
Str::after($originalString, $matchString) / replace everything after the $matchString is found in $original
Str::afterLast($originalString, $matchString) / like after, but only last instance of $matchString
Str::ascii() / transliterate <translate> a string into ascii values
Str::before($haystack, $needle) / return everything in haystack before needle
Str::beforeLast($haystack, $needle) / return everything in haystack before last match of $needle
Str::between($haystack, $beginNeedle, $endNeedle) / returns the part of $haystack between the two needles
Str::betweenFirst($haystack, $beginNeedle, $endNeedle) / returns tightest part of $haystack between $beginNeedle and $endNeedle
Str::camel('foo_bar') / fooBar
Str::contains($haystack, $needle) / Check whether $needle exists in $haystack. Case sensitive. Can also pass an array of $needles
Str::containsAll($haystack, [$needles...]) / Check whether all $needles exist in $haystack
Str::ensWith($haystack, $needle) / check if the string ends with $needle. Can also pass an array of needles to check if it ends in any
Str::excerpt($haystack, $needle, ['radius' => $x, 'ommision' => '(...)']) / Finds the first $needle in $haystack and extracts it. The return value by default has 100 characters on each side from the original string. The omission text is added to the beginning or end of the returned string if not enough characters to add, "..." by default.
Str::finish($original, $finish) / if $original doesn't end with $finish, it's appended.
Str::headline($original) / replace special casing (snake, camel, etc.), hyphens or underscores into spaces and capitalize each first letter. Makes headlines
Str::inlineMarkdown($string) / convert CommonMark markdown into html string
Str::is('*foo', 'barfoo') / true. This uses wildcards to determineif a string matches a pattern
Str::isAscii($string) / check if string is 7 bit ASCII
Str::isJson() / is string JSON?
Str::isUlid / is string Ulid
Str::isUuid / is string UUID
Str::kebab($string) / convert to kebab-case
Str::lcfirst($string) / lowercase first character
Str::length($string) / return length of string
Str::limit($string, $n, $append='') / Return copy of first $n characters of the string with $append appended onto the end
Str::lower($string) / convert string to lowercase
Str::markdown($string) / converts markdown into html. Top level html is always a block-level element (I think this means like a span would be wrapped in a div)
Str::mask($string, '*', $offset, $chars) / Replace $chars number of instances with given character at +/- $offset. E.g. ('example', '#', 2, 2) -> ex##ple
Str::orderedUuid() / returns "timestamp first" (for ordering) that can be stored in an indexed column
Str::padBoth($string, $desiredLength, $char = ' ') / Pad original $string with $char on both sides until it reaches the desired length
Str::padLeft / like padBoth
Str::padRight / like padBoth
Str::password($length=32) / Generates a secure password
Str::plural($word, $plural=2) / By default return plural form of $word. If $plural is passed 1, returns singular
Str::pluralStudly($wordString, $plural=2) / like plural, but instead of a single word take an  StudlyCapitalized string like TheseExample -> TheseExamples
Str::random($length) / generate random string  of specified length
Str::remove($needle, $haystack) / $remove instances of $needle from $haystack. Can pass false as third argument to ignore case
Str::replace($needle, $replacementNeedle, $haystack) / replace instances of $needle in $haystack with the new $needle. Can pass optional 4th arg for case sensitivity
Str::replaceArray($needle, $sequentialNewNeedlesArray, $haystack) / replace instances of $needle in $haystack sequentially with values in $sequentialNewNeedlesArray
Str::replaceFirst($needle, $newNeedle, $haystack) / replace first instance of $needle in $haystack with the new $needle
Str::replaceLast($needle, $newNeedle, $haystack) / like replaceFirst
Str::reverse($string) / reverse $string
Str::singular($string) / converts string to it's singular form
Str::slug($string) / generate url-friendly-slug from a string
Str::snake($string) / converts string to snake case
Str::squish($string) / remove extra whitespace from a string including          between          words -> between words
Str::start($string, $prepend) / Prepends instance of $prepend to $string, if $string does not already start with that
Str::startsWith($haystack, $needle) / determine if a $haystack begins with $needle. Can also pass array of posssible $needles
Str::studly($string) / converts to StudlyCase
Str::substr($haystack, $startIndex, $length) / return $length length substring in $haystack starting at $startIndex
Str::substrCount($haystack, $needle) / return number of times $needle occurs in $haystack
Str::substrReplace($haystack, $replacement, $index, $cutChars) / At $index in $haystack, remove $cutChars # of characters, and insert the $replacement test
Str::swap(['needle1' => 'newNeedle1', 'needle2' => 'newNeedle2', etc.], $haystack) / replace instances of needle1 and needl2, etc. with new needles in haystack
Str::title($string) / converts string to Title Case
Str::of('string')->toHtmlString() / converts a normal string to Illuminate\Support\HtmlString to show in Blade templates
Str::ucfirst($string) / upper case the first character
Str::ucsplit($string) / 'FooBar' => ['Foo', 'Bar']
Str::upper($string) / uppercase string
Str:ulid() / generate a ulid, a compact time-ordered unique identifier
Str::uuid() / generate uuid
Str::wordCount($string) / number of words in a string
Str::words($string, $numberOfWords, $append='') / Truncate $string to $numberOfWords words, then append the $append string
str() / returns Stringable instance. Alias of Str::of($string). Without an Argument it returns an Illuminate\Support\Str instance so str()->anyOfTheAboveMethods($string) would work
trans('message.key') / return the value of the message.key in the language files
trans_choice('message.key', $count) / like trans but with inflection. I think this is like spanish plural, mr/ms/mrs. type of thing

Fluent Strings
Fluid strings are a more fluid, object-oriented string interface. They canb e changed.
Str::of($haystack)->after($needle) / return all of $haystack after $needle/
Str::of($haystack)->afterLast($needle) / return all of $haystack after last instance of $needle
Str::of($string)->append($toAppend) / append $toAppend to the end of $stirng
Str::of($string)->ascii() / convert to ascii
Str::of('/something/something/something.ext')->basename('.ext') / return only last part of string, optionally passing extension to remove -> something
Str::of($haystack)->before($needle) / return all of $haystack before $needle
Str::of($haystack)->beforeLast($needle) / return all of $haystack before last instance of $needle
Str::of($haystack)->between($startNeedle, $endNeedle) / return all of haystack between $startNeedle and $endNeedle
Str::of($haystack)->betweenFirst($startNeedle, $endNeedle) / return smallest possible substring of $haystack between $startNeedle instance and $endNeedle instance
Str::of($string)->camel() / convert to camelCase
Str::of(ClassName::class)->classBaseName() / returns ClassName class name without namespace
Str::of($haystack)->contains($needle) / returns if $haystack contains $needle. Can also pass array of possible $needles
Str::of($haystack)->containsAll($needles) / returns if $haystack contains every needle in $needles
Str::of($pathLikeString)->dirname($trimLevel=0) / returns parent directory part of string e.g. /home/user/calvin/test => '/home/user/calvin'. Can optionally trim(e.g. 1) -> /home/user
Str::of($haystack)->excerpt($needle, ['radius' => 3]) / 'an example' (xa, 1) -> 'exam'
Str::of($haystack)->endWith($needle) / does $haystack end with $needle. Can also pass an array of possible $needles to check if it ends in any of them
Str::of($haystack)->exactly($needle) / is string exactly equal to $needle
Str::of($string)->explode($delimeter) / separate $string into an array, breaking on $delimeter
Str::of($string)->finish($finishString) / if $string does not end with $finishString, append it
Str::of($string)->headline() / convert non-trasitional casings (snake, camel, etc.), underscores or hyphens into appropriate case for headline This Is A Headline
Str::of($string)->inlineMarkdown() / converts Markdown into inline HTML. Unlike markdown, it does not wrap the top level element in a block element
Str::of($string)->is('some*pattern') / determine if string matches wildcard pattern foobar + foo* -> true
Str::of($string)->isAscii() / determine if $string is Ascii
Str::of($string)->isEmtpy() / determine if given string is empty
Str::of($string)->isNotEmpty() / determine if string is not empty
Str::of($string)->isJson() / determine if string is json
Str::of($string)->isUlid() / determines if the string is a Ulid
Str::of($string)->isUuid() / determines if the string is a UUID
Str::of($string)->kebab() / converts the $string to kebab-case
Str::of($string)->lcfirst() / return the string with the first character lower cased
Str::of($string)->length() / return the string length
Str::of($string)->limit($n, $append='') / truncate $string to $n characters. Then append $append.
Str::of($string)->lower() / convert the string to lwoercase
Str::of($string)->ltrim() / trim the left side fo the string
Str::of($string)->markdown() / convert a string of markdown into HTML
Str::of($string)->mask($char, $index, $length). Starting at $index (posibly negative) replace abs($length) characters in $string with $character
Str::of($string)->match($regexPattern) / return the part of the $string that matches the pattern
Str::of($string)->matchAll($regexPattern) / return a collection of parts of the $string that matches the regex pattern
Str::of($string)->isMatch($regex) / returns if $string matches $regex
Str::of($string)->newLine() / append a new line character to a string
Str::of($string)->padBoth($length, $fillChar) / add $fillChar to both ends of $string until it's $length characters
Str::of($string)->padLeft($length, $fill) / add $fill strings to the left of $string until it's at $length
Str::of($string)->padRight($length, $fill) / like padLeft
Str::of($string)->pipe($callable) / pass $string to the $callable
Str::of($string)->pural($plural=2) / return the word string to plural. If the optional parameter is set to 1, it will return the singular
Str::of($string)->prepend($prepend) / prepend $prepend string on to $string
Str::of($haystack)->remove($needle(s)) / remove the $needle or array of $needles from the $haystack string. Can pass false as second parameter to ignore case.
Str::of($haystack)->replace($oldNeedle, $newNeedle) / remove instances of $oldNeedle in the $haystack string with the $newNeedle. Can pass an optional case sensitive parameter as last arg
Str::of($haystack)->replaceArray($oldNeedle, $sequentialNewNeedles) / sequentially remove instances of $oldNeedle in $haystack with values from the $newNeedleArray
Str::of($haystack)->replaceFirst($oldNeedle, $newNeedle) / replace first instance of $oldNeedle in the $haystack string with $newNeedle
Str::of($haystack)->replaceLast($oldNeedle, $newNeedle) / replace last instance of $oldNeedle in the $haystack string with $newNeedle
Str::of($haystack)->replaceMatches($regexPattern, $newNeedle) / replace all matches of the regex pattern in $haystac kwith the $newNeedle. Can also specify $newNedle as a closure accepting the regex match as an argument
Str::of($string)->rtrim() / trim the right side of a string
Str::of($string)->scan($sscanfPHPFunctionPattern) / this is pattern is like the reverse of the printf pattern. It matches according to that
Str::of($string)->singular() / convert the $string to it's singular form
Str::of($string)->slug($delimeterCharacter='-') / generate a url-friendly-slug from the given string
Str::of($string)->snake() / converts $string to snake_case
Str::of($string)->split($regex) / split the string into a collection using the $regex pattern
Str::of($string)->squish() / remove extra whitespace from a string          including       between      words -> including between words
Str::of($string)->start($prepend) / if $string does not start with $prepend, add a single instance of it to the front
Str::of($haystack)->startsWith($needle) / check if $haystack starts with $needle
Str::of($string)->studly() / conert the string to StudlyCase
Str::of($string)->substr($start, $length) / return the substring of $string at index $start for $length (both can be negative)
Str::of($string)->subStrReplace($insertString, $index, $length) / remove $length characteers from $haystack at $index position and insert $insertString
Str::of($haystack)->swap(['needle1' => $newNeedl1, 'needle2' => $newNeedle2...]) replace instances of needle array with their replacement values in haystack
Str::of($string)->tap(closure) / pass an instance of string to the closure. The original string is returned by the method.
Str::of($string)->test($regex) / does $string match $regex pattern t/f
Str::of($string)->title() / converts to Title Case
Str::of($string)->trim() / trim the string
Str::of($string)->ucfirst() / upper case the first character of hte string
Str::of($string)->ucsplit() / break string at start of upper cased letters
Str::of($string)->upper() / capitalize the entire string
Str::of($string)->when($truthyValue, closure) / when $truthyValue is true, the closure is called on the $string. Can optionally pass a third argument with a closure to call when not truthy
Str::of($haystack)->whenContains($needle, $truthClosure, $falseClosure=fn(){}) / like when(), but truthy value is determined by whether needle is in haystack
Str::of($haystack)->whenContainsAll($needlesArray, $truthClosure, $falseClosure=fn(){}) / like whenContains, but all  needles must be in the haystack
Str::of($string)->whenEmpty($closure) / when the $string is empty, the closure is called
Str::of($string)->whenNotEmpty($closure) / oppositve of whenEmpty
Str::of($haystack)->whenStartWith($needle, $trueClosure, $falseClosure=fn(){}) / like when, but truth condition is set by $haystack starting with needle
Str::of($haystack)->whenEndWith($needle, $trueClosure, $falseClosure=fn(){}) / oppossite of whenStartsWith()
Str::of($haystack)->whenExactly($needle, $trueClosure, $falseClosure=fn(){}) / like when(), but truth value determined by $haystack === $needle
Str::of($haystack)->whenNotExactly($needle, $trueClosure, $falseClosure=fn(){}) / opposite of whenExactly
Str::of($haystack)->whenIs('wildcard-needle-*-pattern', $trueClosure, $falseClosure=fn(){}) / like when, but uses wildcard pattern match on $haystack
Str::of($string)->whenIsAscii($trueClosure, $falseClosure=fn(){}) / like when, but uses whether the $string is valid ASCII for truthy value
Str::of($string)->whenIsUlid($trueClosure, $falseClosure=fn(){}) / dumb. Like when, but uses whether $string is valid ulid for truthy value
Str::of($string)->whenIsUuid($trueClosure, $falseclosure=fn(){}) / like whenIsUlid, but for UUID
Str::of($haystack)->whenIsTest($regexNeedleCondition, $trueClosure, $falseClosure=fn(){}) / like when, but uses whether the $haystack matches the regex expression
Str::of($string)->wordCount() / number of words in $string
Str::of($string)->words($n, $append='') / Truncate string to $n words and append the $append string

URLs
$url = action([Controller::class, 'action'], ['id' => 1]) / generate url for given controller
$url = asset('img/somePhoto.jpg') / generates a url for an asset using the scheme of the request and the ASSET_URL from .env
$url = secure_asset('img/somePhoto.jpg') / generates a url for an asset ussing https
$url = route('route.name', ['id' => 1]) / generate a url from a route name
$url = url('relative/url/path', [1]) / generates a url to a given path
$url = secure_url('relative/url/path', [1]) / generates a url to the relative path using HTTPS
to_route('route.name', 'id' => 1]) / generate a redirect response to a named route

Miscellaneous
-------------
abort($httpCode, $message) / throw an HTTP exception
abort_if($condition, $code, $message) / if $condition, throw an HTTP exception
abort_unless($reverseCondition, $code, $message)  / reverse of abort_if
app() / return service container instance. If a service class or interface path is passed in, the service container will resolve that
auth() / return authenticator interface. Same as Auth::. Can also pass a guard instance auth('guard-instance')
back() / returns redirect response to user's previous location
bcrypt($value) / hash given value
blank() / '', '    ', null, collect(). Basically like converting to a string, calling trim and seeing if it's an empty string
broadcast($event) / broadcast event to it's listeners
cache($key, $value=null) / if just key, get the item from the cache. If a value is passed, this function sets the item in the cache
class_uses_recursive(ClassName::class) / return all traits used by a class, including it's parent classes
collect() / create a collection from a given value
config('config.var', $default=null) / get a configuration value using dot notation. Can define a default value in case the key is not set
cookie('name', 'value', $minutes) / create a new cookie instance
csrf_field() / esp. in blade, create a hidden html input field that holds the value of hte csrf token
csrf_token() / get the actual value of the current csrf token
decrypt($value) / decrypt the encrypted $value
dd($variable) / dump the given variable to output andstop executation of the script
dispatch(new App\Job\SomeJob) / dispatch Job to the queue
disptach_sync(new App\Jog|SomeJob) / dispatch job to sync queue, so that it is processed immiediately
dump($variable) / dump the given variable to the output stream
encrypt($value)/ encrypt the given value
env('SOME_ENV_VAR', $default=null) / retrieve an environment variable
event(new SomeEvent()) / dispatch an event to the event listeners
fake() / resolves faker singleton from container for creating fake data e.g. fake()->name()
fill($variable) / opposite of blank()
info($someString, [...$params]) / write info entry in log
logger($something, [...$params]) / write debug entry in log
method_field('DELETE') / generate a hidden html input field with the spoofed value of the form HTTP verb. Used for turning POST forms into e.g. DELETE forms
now() / Carbon instance for the current time
old('value', $default=null) / retrieve old input flashed to the session. Can pass an entire $model as the second parameter to use the property as the default
optional($any)->property / this is basically a longer version of $any?->, but it will trap other types of exceptions I guess
optional($nullable, closure) / same function as above, but here the closure is  only called if $nullabe is not null
policy(App\Models\Class::class) / returns policy for a class, a security class
redirect($to, $status, $headers, $https)/ returns a redirect to the $path
report($e) / with a string, it will raise an exception. With an exception, it will call the reportable method on the exception
report_if($condition, $e) / like report, but conditional
report_unless($condition, $e) / reverse report_if
request('key'=null) / return current request items. If  key is passed retrieve that user input from the request
rescue(closure) / execute closure and catch any exception. Any exception are sent to the exception handler. The request continues regardless. Can pass a default return value.
resolve('Some\Class\Or\Interface') / resolve the argument using the service container
response($contents, $status, $headers) / generate a Response instance
retry($times, $closure, $waitMs) / retry the closure $times times. It will be retried in the case on an exception. It will wait $waitMs between eac htry.
session('key', 'value'=null) / either retrieve the item with key 'key' from the session or set it to value (if a second argument is passed)
tap($value, closure) or tap($value)->methodOnValueObject() / tap ensures the return value from the closure or method is always the original value
throw_if($truthy, ExceptionClass::class) / throw an exception if $truthy
throw_unless($truthy, ExceptionClass::class) / opposite of throw_if
today() / Carbon instance of current day
trait_uses_recursive(TraitClass::class) / return all traits used by a trait
transform($value, closure) / if $value is not blank, transform will call the closure with that $value and return the result.
validator($data, $rules, $messages) // Same as Validator::, creates a new validator  instance
value($scalarOrclosure) / if passed a $value, returns itself. If passed a closure, evaluates that.
view('some.view') / returns a view (rendered blade) instance
with($value, $closure=(){}) / returns the $value it was given. If a closure is passed as the second argument, that is evaluated with $value and returned

Benchmark::dd(closure) / test how long a closure takes to complete
Lottery::odds(1, 20)->winner(closure)->loser(closure)->choose() / Only execute winner closure for ~1/20 calls
Pipeline::send($variable)->through([$closure1, $closure2, $closure3...])->then($finalClsoure); / through can also take invokable classes / methods
Sleep::for($n)->second() / several variations, but basically it pauses execution of the script
Sleep::fake() / at the top of a test, this will prevent sleep calls from firing and slowing down the test
Sleep::assertSlept / if turned sleep of during testing, can assert that it would have gone as expected

Http Client
-----------
Basic Requests and Responses
Used to make outgoing HTTP requests with other web applications
Http::get('https://www.google.com'); / get | post | head | put | patch | delete
$response->body | json | object | collect | status | successful | redirect | failed | clientError | header | headers
can also just use array access like $response['some-key']
Http::withUrlParameters(['endpoint' => $x, 'page' => $y, 'version' => $z...])->get('{+endpoint}...') / use url template parameters to build request
Http::dd()->get('something') / will dump the request before it's sent
Http::get('url', ['someVar' => 1]) / Can pass data through request as a parameter. Can use this for other methods. By default, it's json encoded.
Http::asForm()->post('some-url', [$formVars...]) / will encode the data as application/x-www-form-urlencoded
Http::withBody(base64_encode($photo, $contentType)->post(...) / include a raw request body in the request
Http::attach('file.pdf', file_get_contents('some-file')) / make a multi-part request including a file
Http::withOptions([...$guzzleOptions]) / specify additional guzzle options

Headers
Http::withHeaders(['allow_origin' => $x])->post('some-url') / include headers on the request
There are headers for setting specific header types, but why not just use the above

Authentication
Http::withBasicAuth($un, $pw)->post(...) / use username and password
Http::withDigestAuth('un', 'password')->post('...') / with diget auth
Http::withtoken('token')->post('...') / with token

Timeout
Http::timeout(3)->get('...') / wait max 3 seconds for response

Retries
Http::retry($tries, $msBetween)->post('...') / retry $tries times, waiting $msBetween in between
Can modify the request in between tries by passing a closures as the third argument)

Exceptions
$response->throw() or throwIf($conditionOrclosure) / This will throw an exception if it was an error (400, 500, etc.) response. Can add another condition to check before throwing.
throw() will return the response instance if there was no error, allowing chaining
Can pass a closure to the throw method to execute before the exception is thrown.

Middleware
Http::withMiddleware(Middleware::someGuzzleMiddleware())->get('...')

Pool
Http::pool(fn (Pool $pool) => [$pool->as('first')->get('...'), $pool->as('second')->get('...')]) -> $responses['first'] / send multiple requests concurrently
Additionally Http:: methods should be placed on each request rather than chained on the pool method

Macro
Http::macro('github', function() { return Http::withHeaders(['X-Example' => 'example',])->basUrl('https://gihub.com') in AppServiceProvider
Http::github()->get('/') / for example. The idea is that common Http method patterns can be aliased

Tests
Http::fake() / return empty 200 status codes
Http::fake([
    'github.com/*' => Http::response(['foo' => 'bar', 200, $headers),
    'google.com.com/*' => Http::response(['google', 200, $headers),
    ]); / return different data based on url patterns
Http::fake(['github.com/*' => Http::sequence()->push('First response', 200)->push('Second response', 200')...]);
Http::fake(closure(Request $request) {}) / customize the faked response using a closure
Http::preventStrayRequests() / after having written several Http::fake methods, call this at the top of a test to prevent making any real requests to url patterns that don't have a corresponding Faked response
Http::assertSend(function(Request $request){}) / in a test, receives the request and should return a boolean whether it was proper
Http::assertNotSent(closure) / e.g. testing that old endpoint not hit in test
Http::assertSentCount($n) / assert $n requests sent
$recorded =Http::recorded()  / gathers all the requests and responses generated during the test

Events
RequestSending and ( ResponseReceived or ConnectionFailed ) are the three events fired during a request
All 3 include a $request property. The Response event contains the $response

Localization
------------
php artisan lang:publish / publish lang directory and associated files
Language files return array of key to translation
lang/en/messages.php / return ['welcome' => 'Welcome to our app']. In these, use short keys to describe the messages
or lang/es.json /  This is better for longer translations: {"I love programming.": "Me encanta programar."}
config/app defines 'locale' config option. Can also define at runtime with App::setLocale($location)
__('messages.php-short-key') or __('I love programming.') will retrieve the value from the translation files
'with_key' => ''this message contains a :key' -> __('messages.with_key', ['key' => $someKey]) / Can define placeholders in translation strings
The capitalization of :key will be maintained. e.g. if KEY is written like this, the passed value (calvin) would be written CALVIN
in the boot section of a service, can define Lang::stringable(function(Model $model){}) to over-ride the __toString method for use when providing that object as a placeholder in a a translation string
A translation string can define 'this is the singular version|These are the plural versions' of a string.
Can define the values even '{0} This is none| [1,19] These are some|[20,*] These are many',
trans_choice('some_translation_string', $amt) / This will display the right string from the last line

Pluralizer::useLanguage('spanish') / Separately from locale language above, can tell pluralizer to use another language

For packages development, can place lang files in lang/vendor/{package}/{locale} to automatically over-ride / coexist with laravels

Mail
----
Can define configuration for 3rd parter servers or smtp server in config/mail.php
Common ones are Mailgun, Postmark and Amazon SES
Can define a failover just like above. This will take a list of failover mailers and then this will be set as the default mailer

Generating Mailables
Each type of email is represented as a mailable class sotre din app/Mail
php artisan make:mail OrderShipped
The envelope method defines the subject and sometimes recipients

Writing Mailables
The content method returns a Content object that defines the Blade templates for the content
2 ways to specify the sender:
can specify address sender in Mailer Class: return new Envelope(from: new Address('calvin@calvin.com', 'Calvin Hill'), subject: 'Some thing')
can specify global "from" address in config/mail.php

can specify view in the content method: content(){return new Content(view: 'emails.oreders.shipped'));}
can specify a plain-text version of emails that would be used in place of the normal html emails: Content(view: 'email.some.view', text: 'email.some.view-text')

Can pass context to an email by defining a public property on the mailable class and using {{ $propertyPath }}
Can also pass context via content: Content(view: 'some.view', with: ['var1' => var1])

return [Attachment::fromPath('/some/file/path')]; / add attachments to an email via the attachments method on the Mailable class:
Attachment::fromStorage() / attach a file from the default file system disk (s3, minio, etc.) with
Attachment::fromStorageDisk('some-disk, 'path-to-file') / specify the disk to attach the fiel from
Atttachment::fromData(closure, $name) / useful, if for example, you already have a variable in memory holding hte file and want to return it w/o re-reading from disk

(in blade) <img src="{{ $message->embed($pathToImage) }}"> / This will embed an inline image in an email
The message variable is automatically available in html emails
<img src="{{ $message->embedData($data, 'some-name.jpg') }}"> / embed a raw image string previously read out of disk into memory
A model can implement the Attachable interface, including hte toMailAttachment method. This should return an object of the Attachment class
Then, using the above, the attachment method can just pass the models public function attachments() {return [$this->photo];}

The mailable can implement the headers method, which should return like: return new Headers('message-id', ['references'], text: ['X-Custom-Header' => 'Custom Value',]);
The envelope constructor can accept a third argument for passing tags and metadata. Mailgun and Postmark use these to group and track emails

Can pass the "using" closure parameter to the Envelope constructor. This would have a single argument of Symfony\Component\Mime\Email. It allows customizing the email message before sending.

Markdown Mailables
php artisan make:mail OrderShipped --markdown=emails.orders.shipped / generate a markdown template in addition to the Mailable
Then when defining the content use return new Content(markdown: 'emails.orders.shipoped', ...) rather than view:
Markdown messages are a combination of blade and Markdown.
<x-mail::button :url="$url" color="success"> / button markdown component
<x-mail::panel> / panel component
<x-mail::table> / Accepts a markdown table as it's content
php artisan vendor:publish --tag=laravel-mail / publish all hte laravel markdown mail components so they're visiable/editable

Sending Mail
Mail::to($user) | Mail::to(collect($users)) | Mail::to('calvin@calvinhill.com')
If passing a $user object or collection of $users, the mailer automatically uses $name and $email properties
Mail::to(...)->send(new MailableClass($argument)) / the send method is chained off of the "to" method to actually send the email
Mail::to('...')->cc('...')->bcc('...') / Can also specify cc and bcc
Mail::mailer('some-config-mailer')->to.. / send mail using a manually specified mailer

Mail::to('...')->cc('...')->etc('...')->queue(new MailableClass($argument) / queue sending the email
Mail::to('...')->cc('...')->etc('...')->later(now()->addMinutes(10), new MailableClass($argument)) / queue the message but delay delivery 10 minutes
Mail::to('...')->cc('...')->etc('...')->queue((new MailableClass($argument)->onConnection('queue-connection')->onQueue('queue'))
if the Mailable implements the ShouldQueue interface, then the mailable will always be queued, even if it was called with send()
If a mailable is queued after in the middle of a database transaction, it may not reflect the changes
A specific Mailable instance can be marked as afterCommit(): (new MailableClass($argument))->afterCommit()
Or $this->afterCommit() can be called in the constructor to apply to all instances.

Rendering Mailables
(new Mailable($argument))->render() / return the html content of the mailable without sending it
returning a mailable instance from a controller will render a response like a normal blade view

Localizing Mailables
Mail::to('...')->locale('es')->send(...') / send using the espanol locale
if the user model has implemented the HasLocalePreference interface and that model is passed into the "to" method, the mailer will use that locale

Testing
$mailable = new MailableClass($argument);
$mailable->assertFrom($x);
$mailable->assertTo($y);
$mailable->assertHasCC($cc) | $mailable->assertHasBcc($bcc)
$mailable->assertHasReplyTo($replyTo)
$mailable->assertHasSubject($subject)
$mailable->assertSeeInHtml($someStringInHtml)
$mailable->assertSeeInText($someTextString)
$mailable->assertHasAttachment('/path/to/file' | Attachment::...)
Best to separate tests for if mail sent vs content of sent mail
Mail::fake(); / covered previously, don't actually send emails
Mail::assertSent(Mailable::class, $numberOfTimesSent)
Mail::assertQueued(MailableClass) / assert that the mailable was put on the queue
can pass a closure to AssertSent to check that the mailable instance passed some condition

Mail & Local Development
During local development, laravel can send emails to logs or a service like Mailpit for inspection
Mail::alwaysTo() / can be set conditionally based on environment so only the developer gets all emails during development

Events
MessageSending event is fired prior to a message being sent
MessageSent event is fired immiediately after

Notifications
Notifications are any method for sending messages to users
Should mostly be short informational messages like status updates / bill paid, etc.

Generating Notifications
php artisan make:notification InvoicePaid / each notification is it's own class

Sending Notifications
use Notifiable / adds method to e.g. User class used like $user->notify(new NotificationClass($argument)) to send notification
Notification::send($users, new NotificationClasss($argument)) / second way to send a notification, like email
Notification::sendNow(...) / like send, but will send immiediately, even if the notification implements ShouldQueue

the "via" method receives the object the notification is being sent to ($user, $customer, etc.) and returns the string of the configuration key of which channel to send it on ('mail', 'slack', etc.)

Implement the ShouldQueue interface qand add the Queueable trait to automatically queue notifications
$user->notify((new Notification($argument))->delay($delay) / delay a notification $delay amount of time
The notification class can define a withDelay method to specify the delay for different channels
Can customize the queue connection per Notification class by defining the $connection property to the key ('redis')
Can implement the viaConnections method on the Notification class to define different queue connections for different notification channels
Can (similarly) implement the viaQueues method on the Notification class to define different queues (NOT CONNECTIONS) for different notification channels
Can call $user->notify((new Notification($argument))->afterCommit() to avoid sending the queued notification until after all relevant database transactions have committed. Can also call this on notification constructor to set it for all instances of that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notifievantof that notificationdatabase transact.
Can also call this on the notification constuctor to set it for all instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all dadatabase transact. an also call this o notification constuctor to set it forall instances  of tons have committed ationsending threla queued notificatio until after all da
Can define a shouldSend method on a queable notification to do a final check before sending

Notification::route('mail', 'outside@outside.com') | route('vonage', '5555555555') | etc. / this is used for sending a notification to someone not stored as a model in the database

Mail Notifications
Notifications that can be sent as email should define as toMail method that takes the $notifiable (user) entity and returns a MailMessage instance
(new MailMessage)->greeting('Hello!')->line('someLine')->lineIf($this->amt > 0, "Due: {$this->amt}")->action('View Invoice', $url);
on MailMessage ->error() will render the call ot action button as an alert/danger
(new MailMessage)->view(['some.view', 'some.text.view'], [$context...]) / Use a blade template. Can also just pass a string for html-only view
(new MailMessage)->from('calvin@dcalvinill.com', 'Calvin') / customize the "from"
Mail will send to 'email' property on notifiable by default.
You can customize this by defining a routeNotificationForMail(Notification $notification) method that returns the email address on the notifiable class
(new MailMessage)->subject($subject) / customize the subject
(new MailMessage)->mailer('mailer-key') / define the mailer to use ('sendgrip', etc.)
php artisan vendor::publish --tag=laravel-notifications / publish the templates for notifications to enable editing

(new MailMessage)->attach('/path/to/file', ['as' => 'fileName.pdf', 'mime' => 'attachment/pdf']) | (new MailMessage)->attach(Attachment::fromPath('..')) / attach a file to a mail notification
not (new MailNotification)->attachFromStorage('...'). Instead have to ->attach('absolute-path')
(new MailMessage)->attachMany([...$attachmentPaths]) / attach many attachments to mail notification
(new MailMessage)->attachData($this->pdfRawData, 'name.pdf') / attach raw string of bytes. Useful if already loaded in memory
(new MailMessage)->tag('some-tag') | (new MailMessage)->metadata('something', $something) / some third providers allow tagging mail notifications for grouping / tracking
(new MailMessage)->withSymfonyMessage(function(Email $message) {}) / customize hte Symfony Mail message before sending the email

Can return a full Mailable object from SomeNotification class' toMail method (instead of a MailMessage, which is like a Notification)
When using Mailable object, the ->to method needs to be defined
If returning a Mailable Object from toMail, when using on-demand notifications (->from syntax above for outside recipients w/ no entity record), the toMail receives a slightly different object instead of the $user entity. It's like an anonymous user. See docs.

Can return any mail notification messages from a controller to view it in the browser.

Markdown Mail Notifications
php artisan make:notification InvoicePaid --markdown=mail.invoice.paid / create a Notification with a markdown mail template, like Emails
Notifications that use Markdown templates should still define a toMail method on the notification class
return (new MailMessage)->markdown('mail.invoice.paid', ['url' => $url])) / example return from toMail method using ->markdown
<x-mail::button :url="$url" color="green"> / like email, this is a default component in the markdown notifications for a button
<x-mail::panel> / default component for a slightly different background
<x-mail::table>(markdown table)</xmail::table> / component for a markdown table
php artisan vendor:publish --tag=laravel-mail / publish markdown components to enable editing them

Database Notifications
php artisan notifications:table / create the table to store notifications in a database table. Then will need to migrate
define a toDatabase or toArray method on the Notification to enable storing in a database. These methods should take the notifiable object and return an associative array of column_names => $values
toArray is also used for broadcasting to js frontend (which I think is dumb)
The default user model already has a relationship to notifications, so can fetch like $users->notifications or $users->unreadNotifications
The Notifiable trait (on user model by default) includes a method markAsRead() to mark a single notification or collection of notifications as read

Broadcast Notifications
// Skipping this because I think it's dumb

SMS Notifications
// Vendor package. Can install as needed
(new VonageMessage)->content($string)->from('1112223333') / After composer installing a couple packages and setting some account ENV vars
Will be routed using a routeNotificationForVonage on notifiable class

Localizing Notifications
$user->notify((new InvoicePaid($invoice))->locale('es')); or Notification::locale('es')->send($users, new InvoicePaid($invoice))
on notifiable, can define preferredLocale() method for notifications and mailables

Testing
Notification::fake() / prevent notifications f rom actually being sent
Notification::assertSentTo([$user], ExampleNotification::class); / assert notification sent. Can also pass a closure in place of the notification class to run a check on the notirfication object
Notification::assertSentOnDemand(ExampleNotification::class) / assert on demand notification was sent

Notification events
NotificationSending / event sent before notification sends
NotificationSent / event fired after notification was sent

Package Development
-------------------
generally config/app.php loads a list of providers
To include a package automatically, add package providers under "extra" : {"laravel": {"providers": ['Here\1'], "aliases": ['Here\2']}}}
If a package was included by composer, can add it under "dont-discover" to prevent automatically discovering it
in boot() method of package service container:
$this->publishes['__DIR__'./../config/package-config.php' => config_path('package-config.php'),]); / call this in boot method of package service provider. After calling vendor:publish, users will have access to config
$this->mergeConfigFrom(...) / merge users published version and pre-existing. Meaning users can selectively over-write config
$this-loadRoutesFrom(__DIR.'/../routes/web.php') / include routes
$this-loadMigrationsFrom(__DIR.'/../database/migrations') / include migrations
$this-loadTranslationsFrom(__DIR.'/../lang', 'this-package') / include language files. Referenced as trans('this-package.something')
Can add lang files to $this->publishes so that they can be published by the user and modified
$this-loadViewsFrom(__DIR.'/../resources/views', 'this-package') / include views. Referenced using view('this-package::some-view')
Laravel also loooks under resources/views/vendor, so if a user places a file at resources/views/vendor/this-package/this-view.blade.php, it would over-ride the above
Can add view files to $this->publishes so they can be published ro resources/views/vendor
Can register a blade component just like normal
Or Can autoload blade components with Blade::componentNamespace('Package\\Views\\Components', 'this-package') for <x-this-package::some-component> tyep namespacing
AboutCommand::add('This Package' , fn () => ['Version' => '1.0.0']) / for describing the package
$this->commands([CommandName1::class, ComandName2::class]) / register commands with laravel
Public assets like css, html and js can also be included in the $this->publishes method
php artisan vendor:publish --tag=public --force will publish those public assets to the users laravel project directory
Can call $this->publishes multiple times in boot and pass differnt tag names as a second argument then,
php artisan vendor:publish --tag=that-tag-name to only publish the specific files or assets to the main project directory

Processes
---------



